<!DOCTYPE html>
<html lang="en">
<head>
  <style>
.diff-add {
  background-color: #e6feed;
  width: 100%;
  float: left;
}
.diff-remove {
  background-color: #ffeef0;
  width: 100%;
  float: left;
}
.diff-break {
  background-color: #f1f8ff;
  width: 100%;
  float: left;
}
code.language-csharp {
  display: inline-block;
}

summary > h1, summary > h2, summary > h3, summary > h4, summary > h5 {
  display: inline-block;
  margin-block-end: .5em;
  margin-block-start: .5em;
}

summary::marker {
  color: #32a1ce;
}

summary::-webkit-details-marker {
  color: #32a1ce;
}

summary {
  outline-color: #32a1ce;
}

header > p {
  font-weight: bold;
}
  </style>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311168-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143311168-1');
  </script>
  <title>Directed Acyclic Word Graphs - Part 2 - First Implementation in C#</title>
  <meta name="author" content="Jean-Bernard Pellerin"/>
  <meta name="description" content="This article describes the DAWG data structure, compares it to other methods of storing a dictionary, and details how to build one."/>
  <meta name="generator" content="100% organic human"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="https://jbp.dev/blog/dawg-first-implementation.html"/>
  <link rel="license" href="https://jbp.dev/licenses.html"/>
  <link rel="stylesheet" href="https://jbp.dev/css/normalize.css"/>
  <link rel="stylesheet" href="https://jbp.dev/css/jeanbern.css"/>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
        {
            "@type": "Organization",
            "@id": "https://jbp.dev/#organization",
            "name": "jbp.dev",
            "url": "https://jbp.dev/",
            "sameAs": [
                "https://www.facebook.com/jbpellerin",
                "https://www.linkedin.com/in/jean-bernard-pellerin-026bbb23",
                "https://twitter.com/jeanbpellerin"
            ],
            "logo": {
                "@type": "ImageObject",
                "@id": "https://jbp.dev/#logo",
                "url": "https://jbp.dev/img/bird.jpg",
                "caption": "jbp.dev"
            },
            "image": {
                "@id": "https://jbp.dev/#logo"
            }
        },
        {
            "@type": "WebSite",
            "@id": "https://jbp.dev/#website",
            "url": "https://jbp.dev/",
            "name": "jbp.dev",
            "publisher": {
                "@id": "https://jbp.dev/#organization"
            }/*,
            "potentialAction": {
                "@type": "SearchAction",
                "target": "https://jbp.dev/?s={search_term_string}",
                "query-input": "required name=search_term_string"
            }*/
        },
        {
            "@type": "WebPage",
            "@id": "https://jbp.dev/blog/dawg-first-implementation.html.html#webpage",
            "url": "https://jbp.dev/blog/dawg-first-implementation.html.html",
            "inLanguage": "en",
            "name": "Directed Acyclic Word Graphs - Part 2 - First Implementation in C#",
            "isPartOf": {
                "@id": "https://jbp.dev/#website"
            },
            "about": {
                "@id": "https://jbp.dev/#organization"
            },
            "description": "Overview of DAWG data structures and an algorithm to create them."
        }
    ]
}
  </script>
</head>
<body>

<header>
  <h2>
      JB's BLOG
  </h2>
</header>

<nav>
  <section>
    <header>
      <h2>Breadcrumb</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/" title="jbp.dev - Homepage">Home</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-first-implementation.html" title="Directed Acyclic Word Graphs - Part 2 - First Implementation in C#">Blog - DAWG - First Implementation in C#</a>
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>DAWG series</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/blog/dawg-basics.html" title="Directed Acyclic Word Graphs - Part 1 - The Basics">The Basics</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-first-implementation.html" title="Directed Acyclic Word Graphs - Part 2 - First Implementation in C#">First Implementation in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-memory-footprint.html" title="Directed Acyclic Word Graphs - Part 3 - Reducing DAWG memory footprint">Reducing DAWG memory footprint</a>
      </li>
      <li>
        Using the DAWG to find spelling errors
      </li>
      <li>
        DAWG performance profiling - part 1
      </li>
      <li>
        Potential DAWG performance improvements
      </li>
      <li>
        Speedy DAWG
      </li>
      <li>
        DAWG performance profiling - part 2
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>Other posts</h2>
    </header>
    <ul>
      <li>
        <a href="https://jbp.dev/blog/custom-binary-serialization.html" title="Custom Binary Serialization in C#">Custom Binary Serialization in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/signing-net.html" title="Signing in .NET">Signing in .NET#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-app-config.html" title="Creating a custom configuration section in .NET">Creating a custom app.config</a>
      </li>
    </ul>
  </section>
</nav>

<main>
<article>
  <header>
    <h1>Directed Acyclic Word Graphs</h1>
    <h2>Part 6 - Performance enhancements</h2>
  </header>

  <section>
    <header>
      <h3>Goals</h3>
    </header>
    <p>
      In this article we're going to explore how to improve the performance of the Lookup function.
      We've created a benchmark suite in the previous article and we're going to use that to measure the effects of our changes.
    </p>
    
    <p>
      We're going to proceed with the first 4 basic steps in performance enhancement.
    </p>
    <ol>
      <li>
        Algorithm refinement
      </li>
      <li>
        Loop hoisting
      </li>
      <li>
        Memory access reduction
      </li>
      <li>
        Branch reduction
      </li>
    </ol>
    
    <p>
      After that, it's time to dig into assembly code and make some weirder optimizations that might not fit on this list.
    </p>
    
    <aside>
      <p>
        When I initially wrote this code, I saw an improvement with each iteration.
        The times listed are from running them once everything was done and I can't explain some of the regressions.
      </p>
    </aside>
  </section>

<ol>
  <li><section>
    <header>
      <h3>Starting point</h3>
    </header>
    <p>
      Here is the very naive implementation of the Wagner-Fischer Algorithm as described in part 4 of this series.
    </p>
    <details>
      <summary><h4>Dawg01.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"><code class="language-csharp"
><span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="csharp-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
{
    <span class="csharp-navy">var</span> builder = <span class="csharp-navy">new</span> StringBuilder(word.Length + (<span class="csharp-navy">int</span>)maxEdits);
    builder.Append(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(<span class="csharp-brown">' '</span>, word.Length + (<span class="csharp-navy">int</span>)maxEdits));
    <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

    <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + maxEdits + <span class="csharp-teal">1</span>][];
    <span class="csharp-navy">for</span>(<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
    {
        matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
    }

    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
    {
        matrix[i][<span class="csharp-teal">0</span>] = i;
    }

    <span class="csharp-navy">for</span>(<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
    {
        matrix[<span class="csharp-teal">0</span>][i] = i;
    }

    Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>);
    <span class="csharp-navy">return</span> results;

    <span class="hljs-function"><span class="csharp-navy">void</span> <span class="csharp-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth</span>)</span>
    {
        Debug.Assert(depth &lt;= word.Length + maxEdits);
        <span class="csharp-navy">if</span> (depth == word.Length + maxEdits)
        {
            <span class="csharp-navy">return</span>;
        }

        <span class="csharp-navy">var</span> firstChild = _graph.FirstChildEdgeIndex[currentNode];
        <span class="csharp-navy">var</span> lastChild = _graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

        <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
        {
            <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
            builder[depth] = currentCharacter;
            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">1</span>; i &lt; matrix[depth].Length; i++)
            {
                <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];
                <span class="csharp-navy">var</span> cost = <span class="csharp-teal">1</span>;
                <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
                {
     cost = <span class="csharp-teal">0</span>;
                }

                matrix[depth + <span class="csharp-teal">1</span>][i] = Min(
     matrix[depth][i] + <span class="csharp-teal">1</span>,
     matrix[depth + <span class="csharp-teal">1</span>][i - <span class="csharp-teal">1</span>] + <span class="csharp-teal">1</span>,
     matrix[depth][i - <span class="csharp-teal">1</span>] + cost);

                <span class="csharp-navy">if</span> (depth &gt; <span class="csharp-teal">0</span> &amp;&amp; i &gt; <span class="csharp-teal">1</span> 
     &amp;&amp; word[i<span class="csharp-teal">-1</span>] == builder[depth - <span class="csharp-teal">1</span>]
     &amp;&amp; word[i<span class="csharp-teal">-2</span>] == builder[depth])
                {
     matrix[depth + <span class="csharp-teal">1</span>][i] = Math.Min(
         matrix[depth + <span class="csharp-teal">1</span>][i],
         matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>] + <span class="csharp-teal">1</span>);
                }
            }

            <span class="csharp-navy">var</span> nextNode = _graph.EdgeToNodeIndex[childEdge];
            <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span> &amp;&amp; matrix[depth + <span class="csharp-teal">1</span>][word.Length] &lt;= maxEdits)
            {
                results.Add(<span class="csharp-navy">new</span> SuggestItem(builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
            }

            Recurse(Math.Abs(nextNode), depth + <span class="csharp-teal">1</span>);
        }
    }

    <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">int</span> <span class="csharp-navy">Min</span>(<span class="hljs-params"><span class="csharp-navy">int</span> a, <span class="csharp-navy">int</span> b, <span class="csharp-navy">int</span> c</span>)</span>
    {
        <span class="csharp-navy">return</span> Math.Min(a, Math.Min(b, c));
    }
}
</code></pre>
    </details>
    <p>
      Benchmark result: 29.75 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Algorithm refinement - part 1</h3>
    </header>
    <p>
      The first implementation is painfully slow.
      A very quick fix we can make is to stop processing when the current graph path cannot possibly generate any valid words.
      The entries in the algorithm's matrix are monotonically increasing, so once we've reached a row where all entries are beyond our maxEdits value, we can stop traversing down that path.
    </p>
    <p>
      A simple way to do so is checking each value as we write it to the matrix.
      By starting with a flag set to false, and setting it to true if we encounter a valid entry, we can check the result once we've done processing the loop and potentially exit early.      
    </p>
    <details>
      <summary><h4>diff Dawg01.cs Dawg02.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> <span class="csharp-navy">childEdge</span> = firstChild; childEdge &lt; lastChild; childEdge++)
  {
<span class="diff-add">+     <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;</span>
      <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
      builder[depth] = currentCharacter;
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">1</span>; i &lt; matrix[depth].Length; i++)
<span class="diff-break">@@</span>
                  <span class="csharp-navy">matrix</span>[<span class="csharp-navy">depth</span> + 1][<span class="csharp-navy">i</span>],
                  <span class="csharp-navy">matrix</span>[<span class="csharp-navy">depth</span> - 1][<span class="csharp-navy">i</span> - 2] + 1);
          }
<span class="diff-add">+</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (matrix[depth + <span class="csharp-teal">1</span>][i] &lt;= maxEdits)</span>
<span class="diff-add">+         {</span>
<span class="diff-add">+             any = <span class="csharp-blue">true</span>;</span>
<span class="diff-add">+         }</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (!any)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         <span class="csharp-navy">continue</span>;</span>
      }

      <span class="csharp-navy">var</span> nextNode = _graph.EdgeToNodeIndex[childEdge];
</code></pre>
    </details>
    <p>
      1.661 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Algorithm refinement - part 2</h3>
    </header>
    <p>
      Again, for our purposes we don't need words that can't possibly fit within the maxEdit distance.
      The matrix contains many entries representing such alignments and word lengths.
      To compute only the relevant entries, we can calculate start and end points for valid entries per row.
      The result is a set of diagonal stripes in the matrix, with entries outside left uncomputed.
    </p>
    <p>
      For this to work, we also need to add values before and after the stripe.
      These values are retrieved during computation for valid entries, so we can simply populate them with maxEdits to represent an invalid transition.
    </p>
    <details>
      <summary><h4>diff Dawg02.cs Dawg03.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;">
<code class="language-csharp"><span class="diff-break">@@</span>
  {
      matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
      matrix[i][<span class="csharp-teal">0</span>] = i;
<span class="diff-add">+     <span class="csharp-navy">if</span> (i &gt; maxEdits)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         matrix[i][i - maxEdits - <span class="csharp-teal">1</span>] = (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         matrix[i][stripeEnd] = (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     }</span>
  }

  <span class="csharp-navy">for</span>(<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
<span class="diff-break">@@</span>
          <span class="cshar-navy">var</span> <span class="cshar-navy">any</span> = <span class="csharp-blue">false</span>;
          <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
          builder[depth] = currentCharacter;
<span class="diff-remove">-         <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">1</span>; i &lt; matrix[depth].Length; i++)</span>
<span class="diff-add">+         <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);</span>
<span class="diff-add">+         <span class="csharp-navy">var</span> to = Math.Min(word.Length + <span class="csharp-teal">1</span>, depth + maxEdits + <span class="csharp-teal">2</span>);</span>
<span class="diff-add">+         <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)</span>
          {
              <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];
              <span class="csharp-navy">var</span> cost = <span class="csharp-teal">1</span>;
<span class="diff-break">@@</span>
          }

          <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = _graph.EdgeToNodeIndex[childEdge];
<span class="diff-remove">-         <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span> &amp;&amp; matrix[depth + <span class="csharp-teal">1</span>][word.Length] &lt;= maxEdits)</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span></span>
<span class="diff-add">+             &amp;&amp; depth &gt;= word.Length - maxEdits - <span class="csharp-teal">1</span></span>
<span class="diff-add">+             &amp;&amp; matrix[depth + <span class="csharp-teal">1</span>][word.Length] &lt;= maxEdits)</span>
          {
              results.Add(<span class="csharp-navy">new</span> SuggestItem(builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
          }
</code></pre>
    </details>
    <p>
      1.313 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Loop hoisting - part 1</h3>
    </header>
    <p>
      The values to and from can be calculated outside the loop.
      This will move some arithmetic and conditionals from inside to outside.
    </p>
    <details>
      <summary><h4>diff Dawg03.cs Dawg04.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">firstChild</span> = _graph.FirstChildEdgeIndex[currentNode];
  <span class="csharp-navy">var</span> lastChild = _graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

<span class="diff-add">+  <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);</span>
<span class="diff-add">+  <span class="csharp-navy">var</span> to = Math.Min(word.Length + <span class="csharp-teal">1</span>, depth + maxEdits + <span class="csharp-teal">2</span>);</span>
<span class="diff-add">+</span>
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
  {
      <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
      builder[depth] = currentCharacter;
<span class="diff-remove">-     <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> to = Math.Min(word.Length + <span class="csharp-teal">1</span>, depth + maxEdits + <span class="csharp-teal">2</span>);</span>
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
      {
          <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];
</code></pre>
    </details>
    <p>
      1.311 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 1</h3>
    </header>
    <p>
      The current implementation can perform multiple reads and writes to the same entry while populating it.
      By storing the result in a temporary variable and doing our computations on it, we save some time.
      This temporary variable can also be carried into the next iteration of the loop, further reducing the number of reads.
    </p>
    <p>
      Carrying it through iterations means we need an initial value before the loop begins.
      If you recall the previous step, we stored a precalculated value before and after each stripe.
      Instead of reading the pre-stripe value, we can calculate it on the fly from existing local variables.
      Now we can also omit the population of these prefix entries.
    </p>
    <details>
      <summary><h4>diff Dawg04.cs Dawg05.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
             {
  matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
  matrix[i][<span class="csharp-teal">0</span>] = i;
<span class="diff-remove">- <span class="csharp-navy">if</span> (i &gt; maxEdits)</span>
<span class="diff-remove">- {</span>
<span class="diff-remove">-     matrix[i][i - maxEdits - <span class="csharp-teal">1</span>] = (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-remove">- }</span>

  <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
  <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">any</span> = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
      builder[depth] = currentCharacter;
<span class="diff-add">+     <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;</span>
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
      {
          <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];
<span class="diff-break">@@</span>
              <span class="cshar-navy">cost</span> = <span class="csharp-teal">0</span>;
          }

<span class="diff-remove">-         matrix[depth + <span class="csharp-teal">1</span>][i] = Min(</span>
<span class="diff-add">+         calculatedCost = Min(</span>
              matrix[depth][i] + <span class="csharp-teal">1</span>,
<span class="diff-remove">-             matrix[depth + <span class="csharp-teal">1</span>][i - <span class="csharp-teal">1</span>] + <span class="csharp-teal">1</span>,</span>
<span class="diff-add">+             calculatedCost + <span class="csharp-teal">1</span>,</span>
              matrix[depth][i - <span class="csharp-teal">1</span>] + cost);

          <span class="csharp-navy">if</span> (depth &gt; <span class="csharp-teal">0</span> &amp;&amp; i &gt; <span class="csharp-teal">1</span> 
              &amp;&amp; word[i<span class="csharp-teal">-1</span>] == builder[depth - <span class="csharp-teal">1</span>]
              &amp;&amp; word[i<span class="csharp-teal">-2</span>] == builder[depth])
          {
<span class="diff-remove">-             matrix[depth + <span class="csharp-teal">1</span>][i] = Math.Min(</span>
<span class="diff-remove">-   matrix[depth + <span class="csharp-teal">1</span>][i],</span>
<span class="diff-add">+             calculatedCost = Math.Min(</span>
<span class="diff-add">+   calculatedCost,</span>
    matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>] + <span class="csharp-teal">1</span>);
          }

<span class="diff-remove">-         <span class="csharp-navy">if</span> (matrix[depth + <span class="csharp-teal">1</span>][i] &lt;= maxEdits)</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (calculatedCost &lt;= maxEdits)</span>
          {
              any = <span class="csharp-blue">true</span>;
          }
<span class="diff-add">+</span>
<span class="diff-add">+         matrix[depth + <span class="csharp-teal">1</span>][i] = calculatedCost;</span>
      }

      <span class="csharp-navy">if</span> (!any)
<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = _graph.EdgeToNodeIndex[childEdge];
      <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>
          &amp;&amp; depth &gt;= word.Length - maxEdits - <span class="csharp-teal">1</span>
<span class="diff-remove">-         &amp;&amp; matrix[depth + <span class="csharp-teal">1</span>][word.Length] &lt;= maxEdits)</span>
<span class="diff-add">+         &amp;&amp; calculatedCost &lt;= maxEdits)</span>
      {
          results.Add(<span class="csharp-navy">new</span> SuggestItem(builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
      }
</code></pre>
    </details>
    <p>
      1.265 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 2</h3>
    </header>
    <p>
      We've just seen that the inner loop can re-use values in the current row from previous iterations.
      We can continue this application of rolling local variables by also storing values read from the previous row.
    </p>
    <p>
      This rolling over from one variable to another is faster than re-reading from memory and the operation can often be free due to register renaming.
      TODO: add a citation for register renaming.
    </p>
    <p>
      While we're at it. some small miscellaneous values can also be read outside of the loop and stored locally for re-use.
    </p>
    <details>
      <summary><h4>diff Dawg05.cs Dawg06.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">currentCharacter</span> = _graph.EdgeCharacters[childEdge];
  builder[depth] = currentCharacter;
  <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
<span class="diff-add">+ <span class="csharp-navy">var</span> previousRowEntry = matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];</span>
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
  {
      <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];
<span class="diff-break">@@</span>
          <span class="cshar-navy">cost</span> = <span class="csharp-teal">0</span>;
      }

<span class="diff-add">+     <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;</span>
<span class="diff-add">+     previousRowEntry = matrix[depth][i];</span>
<span class="diff-add">+</span>
      calculatedCost = Min(
<span class="diff-remove">-         matrix[depth][i] + <span class="csharp-teal">1</span>,</span>
<span class="diff-add">+         previousRowEntry + <span class="csharp-teal">1</span>,</span>
          calculatedCost + <span class="csharp-teal">1</span>,
<span class="diff-remove">-         matrix[depth][i - <span class="csharp-teal">1</span>] + cost);</span>
<span class="diff-add">+         previousRowPreviousEntry + cost);</span>

      <span class="csharp-navy">if</span> (depth &gt; <span class="csharp-teal">0</span> &amp;&amp; i &gt; <span class="csharp-teal">1</span> 
          &amp;&amp; word[i<span class="csharp-teal">-1</span>] == builder[depth - <span class="csharp-teal">1</span>]
</code></pre>
    </details>
    <p>
      1.190 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Loop hoisting - part 2</h3>
    </header>
    <p>
      Now that the code is a little bit easier to read we can notice some more memory reads that can be hoisted out of the loop.
      builder[depth] is simply currentCharacter.
      builder[depth-1] is another loop invariant that we can pull out of both loops.
    </p>
    <details>
      <summary><h4>diff Dawg06.cs Dawg07.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>

  <span class="cshar-navy">var</span> <span class="cshar-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);
  <span class="csharp-navy">var</span> to = Math.Min(word.Length + <span class="csharp-teal">1</span>, depth + maxEdits + <span class="csharp-teal">2</span>);
<span class="diff-add">+ <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? builder[depth - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;</span>

  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
  {
<span class="diff-break">@@</span>
              <span class="cshar-navy">previousRowPreviousEntry</span> + <span class="cshar-navy">cost</span>);

          <span class="csharp-navy">if</span> (depth &gt; <span class="csharp-teal">0</span> &amp;&amp; i &gt; <span class="csharp-teal">1</span> 
<span class="diff-remove">-             &amp;&amp; word[i<span class="csharp-teal">-1</span>] == builder[depth - <span class="csharp-teal">1</span>]</span>
<span class="diff-remove">-             &amp;&amp; word[i<span class="csharp-teal">-2</span>] == builder[depth])</span>
<span class="diff-add">+             &amp;&amp; word[i<span class="csharp-teal">-1</span>] == previousCharacter</span>
<span class="diff-add">+             &amp;&amp; word[i<span class="csharp-teal">-2</span>] == currentCharacter)</span>
          {
              calculatedCost = Math.Min(
   calculatedCost,
</code></pre>
    </details>
    <p>
      1.030 s
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 3</h3>
    </header>
    <p>
      The check for a transposition looks like another good spot to clean up.
      word[i-1] can be replaced with targetCharacter.
      word[i-2] can be replaced by introducing another rolling local variable 
      We can now also remove some boundary checks from the if statement.
    </p>
    <details>
      <summary><h4>diff Dawg07.cs Dawg08.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
          <span class="cshar-navy">builder</span>[<span class="cshar-navy">depth</span>] = currentCharacter;
          <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
          <span class="csharp-navy">var</span> previousRowEntry = matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
<span class="diff-add">+         <span class="csharp-navy">var</span> targetCharacter = <span class="csharp-navy">from</span> &gt; <span class="csharp-teal">1</span> ? word[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;</span>
          <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
          {
<span class="diff-remove">- <span class="csharp-navy">var</span> targetCharacter = word[i - <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;</span>
<span class="diff-add">+ targetCharacter = word[i - <span class="csharp-teal">1</span>];</span>
  <span class="csharp-navy">var</span> cost = <span class="csharp-teal">1</span>;
  <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
  {
<span class="diff-break">@@</span>
      <span class="cshar-navy">calculatedCost</span> + 1,
      <span class="cshar-navy">previousRowPreviousEntry</span> + <span class="cshar-navy">cost</span>);

<span class="diff-remove">- <span class="csharp-navy">if</span> (depth &gt; <span class="csharp-teal">0</span> &amp;&amp; i &gt; <span class="csharp-teal">1</span> </span>
<span class="diff-remove">-     &amp;&amp; word[i<span class="csharp-teal">-1</span>] == previousCharacter</span>
<span class="diff-remove">-     &amp;&amp; word[i<span class="csharp-teal">-2</span>] == currentCharacter)</span>
<span class="diff-add">+ <span class="csharp-navy">if</span> (targetCharacter == previousCharacter</span>
<span class="diff-add">+     &amp;&amp; previousTargetCharacter == currentCharacter)</span>
  {
      calculatedCost = Math.Min(
          calculatedCost,
</code></pre>
    </details>
    <p>
      945.5 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Algorithm refinement - part 3</h3>
    </header>
    <p>
      This code is looking better and better.
      With all those array accesses out of the way, the next most complicated looking step is the Min calculation.
      Let's take a step back and think about what it's trying to solve.
    </p>
    <p>
      The best possible case is the one corresponding to a character match.
      When this happens, we don't need to compare previousRowPreviousEntry against adjacent matrix entries to obtain the best result.
      By switching to an if-else conditional instead of a Math.Min, we can avoid some unnecessary work.
    </p>
    <p>
      Conversely in the case of a transposition, previousRowPreviousEntry cannot possibly be better than the diagonal from the row before it.
    </p>
    <p>
      And finally, we can pull the common +1 out of the Min call and only apply it once.
    </p>
    <details>
      <summary><h4>diff Dawg08.cs Dawg09.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  {
      <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
      targetCharacter = word[i - <span class="csharp-teal">1</span>];
<span class="diff-remove">-     <span class="csharp-navy">var</span> cost = <span class="csharp-teal">1</span>;</span>
<span class="diff-remove">-     <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)</span>
<span class="diff-remove">-     {</span>
<span class="diff-remove">-         cost = <span class="csharp-teal">0</span>;</span>
<span class="diff-remove">-     }</span>

      <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;
      previousRowEntry = matrix[depth][i];

<span class="diff-remove">-     calculatedCost = Min(</span>
<span class="diff-remove">-         previousRowEntry + <span class="csharp-teal">1</span>,</span>
<span class="diff-remove">-         calculatedCost + <span class="csharp-teal">1</span>,</span>
<span class="diff-remove">-         previousRowPreviousEntry + cost);</span>
<span class="diff-remove">-</span>
<span class="diff-remove">-     <span class="csharp-navy">if</span> (targetCharacter == previousCharacter</span>
<span class="diff-remove">-         &amp;&amp; previousTargetCharacter == currentCharacter)</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         calculatedCost = previousRowPreviousEntry;</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+     <span class="csharp-navy">else</span></span>
      {
<span class="diff-remove">-         calculatedCost = Math.Min(</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (targetCharacter == previousCharacter</span>
<span class="diff-add">+             &amp;&amp; previousTargetCharacter == currentCharacter)</span>
<span class="diff-add">+         {</span>
<span class="diff-add">+             previousRowPreviousEntry = matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];</span>
<span class="diff-add">+         }</span>
<span class="diff-add">+</span>
<span class="diff-add">+         calculatedCost = Min(</span>
<span class="diff-add">+             previousRowEntry,</span>
              calculatedCost,
<span class="diff-remove">-             matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>] + <span class="csharp-teal">1</span>);</span>
<span class="diff-add">+             previousRowPreviousEntry) + <span class="csharp-teal">1</span>;</span>
      }

      <span class="csharp-navy">if</span> (calculatedCost &lt;= maxEdits)
</code></pre>
    </details>
    <p>
      916.4 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 4</h3>
    </header>
    <p>
      Taking a look at the variables in the inner-loop, I see maxEdits is only used once.
      Any variable we can remove from the loop will reduce pressure on the registers and eliminate loads and stores to the stack.
    </p>
    <p>
      Currently, entries in the matrix represent the edit distance between strings, going from 0 to maxEdits.
      If we instead prepoulate our matrix with values from -maxEdits to 0, we can then compare against 0 to see if a word is valid.
      Simply subtracting maxEdits from each prepopulated entry will suffice.
    </p>
    <details>
      <summary><h4>diff Dawg09.cs Dawg10.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">for</span> (<span class="cshar-navy">var</span> <span class="cshar-navy">i</span> = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
  {
      matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
<span class="diff-remove">-     matrix[i][<span class="csharp-teal">0</span>] = i;</span>
<span class="diff-add">+     matrix[i][<span class="csharp-teal">0</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>

      <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
      <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
      {
<span class="diff-remove">-         matrix[i][stripeEnd] = (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+         matrix[i][stripeEnd] = <span class="csharp-teal">0</span>;</span>
      }
  }

  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
  {
<span class="diff-remove">-     matrix[<span class="csharp-teal">0</span>][i] = i;</span>
<span class="diff-add">+     matrix[<span class="csharp-teal">0</span>][i] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
  }

  Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>);
<span class="diff-break">@@</span>
           <span class="cshar-navy">previousRowPreviousEntry</span>) + 1;
              }

<span class="diff-remove">-             <span class="csharp-navy">if</span> (calculatedCost &lt;= maxEdits)</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)</span>
              {
       any = <span class="csharp-blue">true</span>;
              }
<span class="diff-break">@@</span>
          <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = _graph.EdgeToNodeIndex[childEdge];
          <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>
              &amp;&amp; depth &gt;= word.Length - maxEdits - <span class="csharp-teal">1</span>
<span class="diff-remove">-             &amp;&amp; calculatedCost &lt;= maxEdits)</span>
<span class="diff-add">+             &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)</span>
          {
              results.Add(<span class="csharp-navy">new</span> SuggestItem(builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
          }
</code></pre>
    </details>
    <p>
      861.1 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Time to break out the big guns - <a href="http://sharplab.io">Sharplab</a></h3>
    </header>
    <p>
      At this point I tried a few things but no matter what I did the results were not encouraging.
      We're now going to look under the hood and see what the compiler sees.
      Using Sharplab, we can see our code at different levels of compilation.
    </p>
    <ol>
      <li>C# (with abstractions and language features expanded)</li>
      <li>IL (Intermediate Language)</li>
      <li>JIT Asm (Native Asm Code)</li>
    </ol>
    <p>
      Instead of a diff, this time I present a minimum viable example that can be used as input for sharplab.
    </p>
    <details>
      <summary><h4>Sharplab Dawg.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="csharp-navy">using</span> System;
<span class="csharp-navy">using</span> System.Collections.Generic;
<span class="csharp-navy">using</span> System.Text;

<span class="csharp-navy">namespace</span> <span class="cshar-navy">PerformanceTesting</span>
{
    <span class="csharp-navy">public</span> <span class="csharp-navy">sealed</span> <span class="csharp-navy">class</span> <span class="cshar-navy">CompressedSparseRowGraph</span>
    {
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> RootNodeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint[] FirstChildEdgeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[] EdgeToNodeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>[] EdgeCharacters;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">ushort</span>[] ReachableTerminalNodes;
    }

    <span class="csharp-navy">public</span> <span class="csharp-navy">sealed</span> <span class="csharp-navy">class</span> <span class="cshar-navy">SuggestItem</span>
    {
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">string</span> Term;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">ulong</span> Count;

        <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">SuggestItem</span>(<span class="hljs-params"><span class="csharp-navy">string</span> term, <span class="csharp-navy">ulong</span> count</span>)</span>
        {
            Term = term;
            Count = count;
        }
    }

    <span class="csharp-navy">public</span> <span class="csharp-navy">sealed</span> <span class="csharp-navy">class</span> <span class="cshar-navy">Dawg</span>
    {
        <span class="csharp-navy">private</span> <span class="csharp-navy">readonly</span> CompressedSparseRowGraph _graph;

        <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">Dawg</span>(<span class="hljs-params">CompressedSparseRowGraph graph</span>)</span>
        {
            _graph = graph;
        }

        <span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="cshar-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
        {
            <span class="csharp-navy">var</span> builder = <span class="csharp-navy">new</span> StringBuilder(word.Length + (<span class="csharp-navy">int</span>)maxEdits);
            builder.Append(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(<span class="csharp-brown">' '</span>, word.Length + (<span class="csharp-navy">int</span>)maxEdits));
            <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

            <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + maxEdits + <span class="csharp-teal">1</span>][];
            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
            {
                matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
                matrix[i][<span class="csharp-teal">0</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;

                <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
                <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
                {
                    matrix[i][stripeEnd] = <span class="csharp-teal">0</span>;
                }
            }

            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
            {
                matrix[<span class="csharp-teal">0</span>][i] = i - (<span class="csharp-navy">int</span>)maxEdits;
            }

            Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>);
            <span class="csharp-navy">return</span> results;

            <span class="hljs-function"><span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth</span>)</span>
            {
                <span class="csharp-navy">if</span> (depth == word.Length + maxEdits)
                {
                    <span class="csharp-navy">return</span>;
                }

                <span class="csharp-navy">var</span> firstChild = _graph.FirstChildEdgeIndex[currentNode];
                <span class="csharp-navy">var</span> lastChild = _graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

                <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);
                <span class="csharp-navy">var</span> to = Math.Min(word.Length + <span class="csharp-teal">1</span>, depth + maxEdits + <span class="csharp-teal">2</span>);
                <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? builder[depth - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;

                <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
                {
                    <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
                    <span class="csharp-navy">var</span> currentCharacter = _graph.EdgeCharacters[childEdge];
                    builder[depth] = currentCharacter;
                    <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
                    <span class="csharp-navy">var</span> previousRowEntry = matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
                    <span class="csharp-navy">var</span> targetCharacter = <span class="csharp-navy">from</span> &gt; <span class="csharp-teal">1</span> ? word[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;
                    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
                    {
                        <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
                        targetCharacter = word[i - <span class="csharp-teal">1</span>];

                        <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;
                        previousRowEntry = matrix[depth][i];

                        <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
                        {
                            calculatedCost = previousRowPreviousEntry;
                        }
                        <span class="csharp-navy">else</span>
                        {
                            <span class="csharp-navy">if</span> (targetCharacter == previousCharacter
                                &amp;&amp; previousTargetCharacter == currentCharacter)
                            {
                                previousRowPreviousEntry = matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];
                            }

                            calculatedCost = Min(
                                previousRowEntry,
                                calculatedCost,
                                previousRowPreviousEntry) + <span class="csharp-teal">1</span>;
                        }

                        <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)
                        {
                            any = <span class="csharp-blue">true</span>;
                        }

                        matrix[depth + <span class="csharp-teal">1</span>][i] = calculatedCost;
                    }

                    <span class="csharp-navy">if</span> (!any)
                    {
                        <span class="csharp-navy">continue</span>;
                    }

                    <span class="csharp-navy">var</span> nextNode = _graph.EdgeToNodeIndex[childEdge];
                    <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>
                        &amp;&amp; depth &gt;= word.Length - maxEdits - <span class="csharp-teal">1</span>
                        &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
                    {
                        results.Add(<span class="csharp-navy">new</span> SuggestItem(builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
                    }

                    Recurse(Math.Abs(nextNode), depth + <span class="csharp-teal">1</span>);
                }
            }

            <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">int</span> <span class="cshar-navy">Min</span>(<span class="hljs-params"><span class="csharp-navy">int</span> a, <span class="csharp-navy">int</span> b, <span class="csharp-navy">int</span> c</span>)</span>
            {
                <span class="csharp-navy">return</span> Math.Min(a, Math.Min(b, c));
            }
        }
    }
}
</code></pre>
    </details>
  </section></li>
  
  <li><section>
    <header>
      <h3>Decompiled C# code</h3>
    </header>
    <p>
      To make observing results easier, we'll first make our code match up with the decompiled C# version.
      Select C# on the Results drop-down in Sharplab and you'll notice quite a few differences.
    </p>
    <p>      
      Most of the required changes involve the Recurse function.
    </p>
    <ul>
      <li>
        Create a struct that will hold the closure variables when Recurse is called.
      </li>
      <li>
        Make the Recurse function static local.
      </li>
      <li>
        Add the closure struct as an argument to Recurse.
      </li>
    </ul>
    <details>
      <summary><h4>diff Dawg10.cs Dawg11.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="csharp-navy">private</span> <span class="csharp-navy">struct</span> ClosureVariable
{
    <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, Dawg11 @<span class="csharp-navy">this</span>, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="csharp-navy">this</span>.word = word;
        <span class="csharp-navy">this</span>.maxEdits = maxEdits;
        _this = @this;
        <span class="csharp-navy">this</span>.matrix = matrix;
        <span class="csharp-navy">this</span>.builder = builder;
        <span class="csharp-navy">this</span>.results = results;
    }

    <span class="csharp-navy">public</span> <span class="csharp-navy">string</span> word;
    <span class="csharp-navy">public</span> uint maxEdits;
    <span class="csharp-navy">public</span> Dawg11 _this;
    <span class="csharp-navy">public</span> <span class="csharp-navy">int</span>[][] matrix;
    <span class="csharp-navy">public</span> StringBuilder builder;
    <span class="csharp-navy">public</span> List&lt;SuggestItem&gt; results;
}

<span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="cshar-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
{
    <span class="csharp-navy">var</span> builder = <span class="csharp-navy">new</span> StringBuilder(word.Length + (<span class="csharp-navy">int</span>)maxEdits);
    builder.Append(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(<span class="csharp-brown">' '</span>, word.Length + (<span class="csharp-navy">int</span>)maxEdits));
    <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

    <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + maxEdits + <span class="csharp-teal">1</span>][];
    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
    {
        matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
        matrix[i][<span class="csharp-teal">0</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;

        <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
        <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
        {
            matrix[i][stripeEnd] = <span class="csharp-teal">0</span>;
        }
    }

    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
    {
        matrix[<span class="csharp-teal">0</span>][i] = i - (<span class="csharp-navy">int</span>)maxEdits;
    }

    <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, <span class="csharp-navy">this</span>, matrix, builder, results);
    Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
    <span class="csharp-navy">return</span> results;

    <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
    {
        <span class="csharp-navy">if</span> (depth == closure.word.Length + closure.maxEdits)
        {
            <span class="csharp-navy">return</span>;
        }

        <span class="csharp-navy">var</span> firstChild = closure._this._graph.FirstChildEdgeIndex[currentNode];
        <span class="csharp-navy">var</span> lastChild = closure._this._graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

        <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)closure.maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);
        <span class="csharp-navy">var</span> to = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
        <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;

        <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
        {
            <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
            <span class="csharp-navy">var</span> currentCharacter = closure._this._graph.EdgeCharacters[childEdge];
            closure.builder[depth] = currentCharacter;
            <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
            <span class="csharp-navy">var</span> previousRowEntry = closure.matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
            <span class="csharp-navy">var</span> targetCharacter = <span class="csharp-navy">from</span> &gt; <span class="csharp-teal">1</span> ? closure.word[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;
            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
            {
                <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
                targetCharacter = closure.word[i - <span class="csharp-teal">1</span>];

                <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;
                previousRowEntry = closure.matrix[depth][i];

                <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
                {
                    calculatedCost = previousRowPreviousEntry;
                }
                <span class="csharp-navy">else</span>
                {
                    <span class="csharp-navy">if</span> (targetCharacter == previousCharacter
                        &amp;&amp; previousTargetCharacter == currentCharacter)
                    {
                        previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];
                    }

                    calculatedCost = Min(
                        previousRowEntry,
                        calculatedCost,
                        previousRowPreviousEntry) + <span class="csharp-teal">1</span>;
                }

                <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)
                {
                    any = <span class="csharp-blue">true</span>;
                }

                closure.matrix[depth + <span class="csharp-teal">1</span>][i] = calculatedCost;
            }

            <span class="csharp-navy">if</span> (!any)
            {
                <span class="csharp-navy">continue</span>;
            }

            <span class="csharp-navy">var</span> nextNode = closure._this._graph.EdgeToNodeIndex[childEdge];
            <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>
                &amp;&amp; depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span>
                &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
            {
                closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
            }

            Recurse(Math.Abs(nextNode), depth + <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);
        }
    }

    <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">int</span> <span class="cshar-navy">Min</span>(<span class="hljs-params"><span class="csharp-navy">int</span> a, <span class="csharp-navy">int</span> b, <span class="csharp-navy">int</span> c</span>)</span>
    {
        <span class="csharp-navy">return</span> Math.Min(a, Math.Min(b, c));
    }
}
</code></pre>
    </details>
    <p>
      When we put this new code into Sharplab, the results are pretty similar.
      We'll use this as our starting point for further refinements.
    </p>
    <p>
      It's a bit slower, but I promise you that's because our struct constructor is slower than just setting non-readonly values as they come.
      That's all in the Lookup function and the assembly code for Recurse has very minimal changes, all in favor of this new version.
      We will catch up soon.
    </p>
    <p>
      915.5 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Using language features</h3>
    </header>
    <p>
      One thing I noticed immediately is that the ClosureVariable struct could be made readonly.
    </p>
    <details>
      <summary><h4>diff Dawg11.cs Dawg12.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="csharp-navy">private</span> <span class="csharp-navy">struct</span> ClosureVariable</span>
<span class="diff-add">+ <span class="csharp-navy">private</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">struct</span> ClosureVariable</span>
  {
<span class="diff-remove">-     <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, Dawg11 @<span class="csharp-navy">this</span>, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span></span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, Dawg12 @<span class="csharp-navy">this</span>, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span>
      {
        <span class="csharp-navy">this</span>.word = word;
        <span class="csharp-navy">this</span>.maxEdits = maxEdits;
<span class="diff-break">@@</span>
        <span class="cshar-navy">this.results</span> = results;
      }

<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">string</span> word;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> uint maxEdits;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> Dawg11 _this;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">int</span>[][] matrix;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> StringBuilder builder;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> List&lt;SuggestItem&gt; results;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">string</span> word;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> Dawg12 _this;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> StringBuilder builder;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;</span>
</code></pre>
    </details>
    <p>
      Before running the benchmark I was curious to see how it would look in Sharplab.
      In IL there are some attributes marking the struct and fields as readonly, and no other changes.
      In JIT Asm there are no changes at all.
      Oh well, at least it's semantically correct so I'll leave the changes in.
    </p>
    <p>
      914.3 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 5</h3>
      <p>Reducing indirection</p>
    </header>
    <p>
      We have some places with very high levels of indirection, ex: closure._this._graph.FirstChildEdgeIndex.
      To simplify this, we'll instead add those variables to the closure struct directly.
      Once done we can also remove the _this member from ClosureVariable.
    </p>
    <details>
      <summary><h4>diff Dawg12.cs Dawg13.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, Dawg12 @<span class="csharp-navy">this</span>, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, CompressedSparseRowGraph graph, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span></span>
  {
      <span class="csharp-navy">this</span>.word = word;
      <span class="csharp-navy">this</span>.maxEdits = maxEdits;
<span class="diff-remove">-     _this = @this;</span>
<span class="diff-add">+     <span class="csharp-navy">this</span>.graph = graph;</span>
      <span class="csharp-navy">this</span>.matrix = matrix;
      <span class="csharp-navy">this</span>.builder = builder;
      <span class="csharp-navy">this</span>.results = results;
<span class="diff-break">@@</span>

  <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">string</span> <span class="cshar-navy">word</span>;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint maxEdits;
<span class="diff-remove">- <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> Dawg12 _this;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> CompressedSparseRowGraph graph;</span>
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> StringBuilder builder;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;
<span class="diff-break">@@</span>
      <span class="cshar-navy">matrix</span>[0][<span class="cshar-navy">i</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;
  }

<span class="diff-remove">- <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, <span class="csharp-navy">this</span>, matrix, builder, results);</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, _graph, matrix, builder, results);</span>
  Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
  <span class="csharp-navy">return</span> results;

<span class="diff-break">@@</span>
          <span class="cshar-navy">return</span>;
      }

<span class="diff-remove">-     <span class="csharp-navy">var</span> firstChild = closure._this._graph.FirstChildEdgeIndex[currentNode];</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> lastChild = closure._this._graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> firstChild = closure.graph.FirstChildEdgeIndex[currentNode];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> lastChild = closure.graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];</span>

      <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)closure.maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);
      <span class="csharp-navy">var</span> to = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
<span class="diff-break">@@</span>
      <span class="cshar-navy">for</span> (<span class="cshar-navy">var</span> <span class="cshar-navy">childEdge</span> = firstChild; childEdge &lt; lastChild; childEdge++)
      {
          <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
<span class="diff-remove">-         <span class="csharp-navy">var</span> currentCharacter = closure._this._graph.EdgeCharacters[childEdge];</span>
<span class="diff-add">+         <span class="csharp-navy">var</span> currentCharacter = closure.graph.EdgeCharacters[childEdge];</span>
          closure.builder[depth] = currentCharacter;
          <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
          <span class="csharp-navy">var</span> previousRowEntry = closure.matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
<span class="diff-break">@@</span>
   <span class="cshar-navy">continue</span>;
          }

<span class="diff-remove">-         <span class="csharp-navy">var</span> nextNode = closure._this._graph.EdgeToNodeIndex[childEdge];</span>
<span class="diff-add">+         <span class="csharp-navy">var</span> nextNode = closure.graph.EdgeToNodeIndex[childEdge];</span>
          <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>
   &amp;&amp; depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span>
   &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
</code></pre>
    </details>
    <p>
      892.4 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 6</h3>
      <p>Reducing indirection</p>
    </header>
    <p>
      Our two dimensional array matrix is another place where we can try to remove some unnecessary lookups.
      If we store a reference to the arrays that we care about, we don't have to make a 2-d access every single time.
    </p>
    <details>
      <summary><h4>diff Dawg13.cs Dawg14.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">to</span> = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
  <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;

<span class="diff-add">+ <span class="csharp-navy">var</span> previousRow = closure.matrix[depth];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> currentRow = closure.matrix[depth + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+</span>
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
  {
      <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = closure.graph.EdgeCharacters[childEdge];
      closure.builder[depth] = currentCharacter;
      <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
<span class="diff-remove">-     <span class="csharp-navy">var</span> previousRowEntry = closure.matrix[depth][<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];</span>
      <span class="csharp-navy">var</span> targetCharacter = <span class="csharp-navy">from</span> &gt; <span class="csharp-teal">1</span> ? closure.word[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
      {
<span class="diff-break">@@</span>
          <span class="cshar-navy">targetCharacter</span> = closure.word[i - <span class="csharp-teal">1</span>];

          <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;
<span class="diff-remove">-         previousRowEntry = closure.matrix[depth][i];</span>
<span class="diff-add">+         previousRowEntry = previousRow[i];</span>

          <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
          {
<span class="diff-break">@@</span>
              <span class="cshar-navy">any</span> = <span class="csharp-blue">true</span>;
          }

<span class="diff-remove">-         closure.matrix[depth + <span class="csharp-teal">1</span>][i] = calculatedCost;</span>
<span class="diff-add">+         currentRow[i] = calculatedCost;</span>
      }
</code></pre>
    </details>
    <p>
      TODO to TODO.
      This is a step I'd tried before breaking out Sharplab but it was a regression at the time.
      Now that we've cleaned up some other parts of the code, I'm willing to bet reduction in register pressure is allowing this change to be positive.
    </p>
    <p>
      810.5 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Algorithm refinement - part 4</h3>
    </header>
    <p>
      It was at this point that I realized I made a mistake.
      The targetCharacter initialization was off by 1.
      It should have been loading the previous char from the array.
    </p>
    <p>
      I have unit tests, they all passed.
      To try to make sense of this I changed the line to assign an invalid character instead.
      All the tests were still passing.
      So either my tests are bad or the first character being checked for a transposition doesn't matter.
      Hint: My tests are fine, see if you can figure it out before reading more.
    </p>
    <p>
      The culprit here is our matrix striping.
      For the early rows where the stripe is not full-width, there is no possible transposition in the first entry because it's before the start of the word.
      For the others rows, because the width of the stripe is maxEdits from the diagonal in both directions, the very first entry can only be valid if there is a character match.
      So there are potential transpositions that we are not acknowledging, but their entry value would have been too high anyways.
    </p>
    <details>
      <summary><h4>diff Dawg14.cs Dawg15.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">targetCharacter</span> = <span class="csharp-navy">from</span> &gt; <span class="csharp-teal">1</span> ? closure.word[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;</span>
</code></pre>
    </details>
    <p>
      771.4 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Branch reduction - part 1</h3>
    </header>
    <p>
      Examining the generated Asm, I notice that the Math.Min are implemented with two jumps and 2 or 3 registers.
      It is an easy change to have it use 2 registers every time and only 1 jump.
      I've applied this in a few places.
      While it seems like there are other instances that could be changed, I tried and found them to be regressions.
      Hopefully after a few more changes we can go back and try again.
    </p>
    <details>
      <summary><h4>diff Dawg15.cs Dawg16.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">closure</span> = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, _graph, matrix, builder, results);
      Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
      <span class="csharp-navy">return</span> results;
<span class="diff-add">+ }</span>

<span class="diff-remove">-     <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span></span>
<span class="diff-add">+ <span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>

<span class="diff-break">@@</span>
      <span class="csharp-navy">var</span> firstChild = closure.graph.FirstChildEdgeIndex[currentNode];
      <span class="csharp-navy">var</span> lastChild = closure.graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

<span class="diff-remove">-         <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = Math.Max(depth - (<span class="csharp-navy">int</span>)closure.maxEdits + <span class="csharp-teal">1</span>, <span class="csharp-teal">1</span>);</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - (<span class="csharp-navy">int</span>)closure.maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &lt; <span class="csharp-teal">0</span>)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         <span class="csharp-navy">from</span> = <span class="csharp-teal">0</span>;</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+</span>
<span class="diff-add">+     <span class="csharp-navy">from</span>++;</span>
<span class="diff-add">+</span>
      <span class="csharp-navy">var</span> to = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
<span class="diff-remove">-         <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : <span class="csharp-brown">' '</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;</span>

<span class="diff-break">@@</span>
              }
              <span class="cshar-navy">else</span>
              {
<span class="diff-add">+                 <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)</span>
<span class="diff-add">+                 {</span>
<span class="diff-add">+                     calculatedCost = previousRowEntry;</span>
<span class="diff-add">+                 }</span>
<span class="diff-add">+</span>
                  <span class="csharp-navy">if</span> (targetCharacter == previousCharacter
                      &amp;&amp; previousTargetCharacter == currentCharacter)
                  {
                      previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];
                  }

<span class="diff-remove">-                     calculatedCost = Min(</span>
<span class="diff-remove">-                         previousRowEntry,</span>
<span class="diff-remove">-                         calculatedCost,</span>
<span class="diff-remove">-                         previousRowPreviousEntry) + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+                 <span class="csharp-navy">if</span> (previousRowPreviousEntry &lt; calculatedCost)</span>
<span class="diff-add">+                 {</span>
<span class="diff-add">+                     calculatedCost = previousRowPreviousEntry;</span>
<span class="diff-add">+                 }</span>
<span class="diff-add">+</span>
<span class="diff-add">+                 calculatedCost++;</span>
              }

              <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)
<span class="diff-break">@@</span>
          <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = closure.graph.EdgeToNodeIndex[childEdge];
<span class="diff-remove">-             <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span></span>
<span class="diff-remove">-                 &amp;&amp; depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span></span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>)</span>
<span class="diff-add">+         {</span>
<span class="diff-add">+             nextNode = -nextNode;</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span></span>
                  &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
              {
                  closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
              }
<span class="diff-remove">-             Recurse(Math.Abs(nextNode), depth + <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-remove">-         }</span>
<span class="diff-remove">-     }</span>
<span class="diff-remove">-</span>
<span class="diff-remove">-     <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">int</span> <span class="cshar-navy">Min</span>(<span class="hljs-params"><span class="csharp-navy">int</span> a, <span class="csharp-navy">int</span> b, <span class="csharp-navy">int</span> c</span>)</span></span>
<span class="diff-remove">-     {</span>
<span class="diff-remove">-         <span class="csharp-navy">return</span> Math.Min(a, Math.Min(b, c));</span>
<span class="diff-remove">-     }</span>
<span class="diff-add">+         Recurse(nextNode, depth + <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+     }</span>
  }
</code></pre>
    </details>
    <p>
      719.5 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Reading assembly code</h3>
    </header>
    <p>
      At this point, anything I try seems to make the benchmark take longer.
      I've been avoiding this, but it's time to parse the Asm output and make sense of it.
    </p>
    <p>
      To make this easier, I'm annotating the ClosureVariable with the StructLayoutAttribute so that I can more readily identify which field is being used.
    </p>
    <details>
      <summary><h4>Sharplab Dawg.cs v2</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"><code class="language-csharp"
><span class="csharp-navy">using</span> System;
<span class="csharp-navy">using</span> System.Collections.Generic;
<span class="csharp-navy">using</span> System.Text;
<span class="csharp-navy">using</span> System.Runtime.InteropServices;

<span class="csharp-navy">namespace</span> <span class="cshar-navy">PerformanceTesting</span>
{
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">struct</span> SuggestItem
    {
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">string</span> Term;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">ulong</span> Count;

        <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">SuggestItem</span>(<span class="hljs-params"><span class="csharp-navy">string</span> term, <span class="csharp-navy">ulong</span> count</span>)</span>
        {
            Term = term;
            Count = count;
        }
    }

    <span class="csharp-navy">public</span> <span class="csharp-navy">sealed</span> <span class="csharp-navy">class</span> <span class="cshar-navy">CompressedSparseRowGraph</span>
    {
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>[] EdgeCharacters;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint[] FirstChildEdgeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[] EdgeToNodeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> RootNodeIndex;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">ushort</span>[] ReachableTerminalNodes;
        <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">ulong</span>[] WordCounts;
    }

    <span class="csharp-navy">public</span> <span class="csharp-navy">sealed</span> <span class="csharp-navy">class</span> <span class="cshar-navy">Dawg</span>
    {
        <span class="csharp-navy">private</span> <span class="csharp-navy">readonly</span> CompressedSparseRowGraph _graph;

        <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">Dawg</span>(<span class="hljs-params">CompressedSparseRowGraph graph</span>)</span>
        {
            _graph = graph;
        }

        [<span class="csharp-teal">StructLayout(LayoutKind.Explicit)</span>]
        <span class="csharp-navy">private</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">struct</span> ClosureVariable
        {
            <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits, CompressedSparseRowGraph graph, <span class="csharp-navy">int</span>[][] matrix, StringBuilder builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span>
            {
                <span class="csharp-navy">this</span>.word = word;
                <span class="csharp-navy">this</span>.maxEdits = maxEdits;
                <span class="csharp-navy">this</span>.graph = graph;
                <span class="csharp-navy">this</span>.matrix = matrix;
                <span class="csharp-navy">this</span>.builder = builder;
                <span class="csharp-navy">this</span>.results = results;
            }

            [<span class="csharp-teal">FieldOffset(0x00)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">string</span> word;
            [<span class="csharp-teal">FieldOffset(0x08)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint maxEdits;
            [<span class="csharp-teal">FieldOffset(0x10)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> CompressedSparseRowGraph graph;
            [<span class="csharp-teal">FieldOffset(0x18)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;
            [<span class="csharp-teal">FieldOffset(0x20)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> StringBuilder builder;
            [<span class="csharp-teal">FieldOffset(0x28)</span>]
            <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;
        }

        <span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="cshar-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
        {
            <span class="csharp-navy">var</span> builder = <span class="csharp-navy">new</span> StringBuilder(word.Length + (<span class="csharp-navy">int</span>)maxEdits);
            builder.Append(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(<span class="csharp-brown">' '</span>, word.Length + (<span class="csharp-navy">int</span>)maxEdits));
            <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

            <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + maxEdits + <span class="csharp-teal">1</span>][];
            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)
            {
                matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];
                matrix[i][<span class="csharp-teal">0</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;

                <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
                <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
                {
                    matrix[i][stripeEnd] = <span class="csharp-teal">0</span>;
                }
            }

            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)
            {
                matrix[<span class="csharp-teal">0</span>][i] = i - (<span class="csharp-navy">int</span>)maxEdits;
            }

            <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, _graph, matrix, builder, results);
            Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
            <span class="csharp-navy">return</span> results;
        }

        <span class="hljs-function"><span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
        {
            <span class="csharp-navy">if</span> (depth == closure.word.Length + closure.maxEdits)
            {
                <span class="csharp-navy">return</span>;
            }

            <span class="csharp-navy">var</span> firstChild = closure.graph.FirstChildEdgeIndex[currentNode];
            <span class="csharp-navy">var</span> lastChild = closure.graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];

            <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - (<span class="csharp-navy">int</span>) closure.maxEdits;
            <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &lt; <span class="csharp-teal">0</span>)
            {
                <span class="csharp-navy">from</span> = <span class="csharp-teal">0</span>;
            }

            <span class="csharp-navy">from</span>++;

            <span class="csharp-navy">var</span> to = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
            <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>) <span class="csharp-teal">0</span>;

            <span class="csharp-navy">var</span> previousRow = closure.matrix[depth];
            <span class="csharp-navy">var</span> currentRow = closure.matrix[depth + <span class="csharp-teal">1</span>];

            <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
            {
                <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
                <span class="csharp-navy">var</span> currentCharacter = closure.graph.EdgeCharacters[childEdge];
                closure.builder[depth] = currentCharacter;
                <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;
                <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
                <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>) <span class="csharp-teal">0</span>;
                <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
                {
                    <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
                    targetCharacter = closure.word[i - <span class="csharp-teal">1</span>];

                    <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;
                    previousRowEntry = previousRow[i];

                    <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
                    {
                        calculatedCost = previousRowPreviousEntry;
                    }
                    <span class="csharp-navy">else</span>
                    {
                        <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)
                        {
                            calculatedCost = previousRowEntry;
                        }

                        <span class="csharp-navy">if</span> (targetCharacter == previousCharacter
                            &amp;&amp; previousTargetCharacter == currentCharacter)
                        {
                            previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];
                        }

                        <span class="csharp-navy">if</span> (previousRowPreviousEntry &lt; calculatedCost)
                        {
                            calculatedCost = previousRowPreviousEntry;
                        }

                        calculatedCost++;
                    }

                    <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)
                    {
                        any = <span class="csharp-blue">true</span>;
                    }

                    currentRow[i] = calculatedCost;
                }

                <span class="csharp-navy">if</span> (!any)
                {
                    <span class="csharp-navy">continue</span>;
                }

                <span class="csharp-navy">var</span> nextNode = closure.graph.EdgeToNodeIndex[childEdge];
                <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>)
                {
                    nextNode = -nextNode;
                    <span class="csharp-navy">if</span> (depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span>
                        &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
                    {
                        closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));
                    }
                }

                Recurse(nextNode, depth + <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);
            }
        }
    }
}
</code></pre>
    </details>
    <p>
      Here is the Asm along with my translation back to the C# code.
    </p>
    <details>
      <summary><h4>Sharplab Asm output</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"><code class="language-csharp"
><span class="csharp-green">// preamble</span>
L0000: push r15
L0002: push r14
L0004: push r13
L0006: push r12
L0008: push rdi
L0009: push rsi
L000a: push rbp
L000b: push rbx
L000c: sub rsp, <span class="csharp-teal">0x58</span>

<span class="csharp-green">// Store 0s on the stack, memory is used when adding a result.</span>
L0010: <span class="csharp-navy">xor</span> eax, eax
L0012: mov [rsp+<span class="csharp-teal">0x38</span>], rax
L0017: mov [rsp+<span class="csharp-teal">0x40</span>], rax

<span class="csharp-green">// Move function parameters into different registers</span>
L001c: mov edi, edx
L001e: mov rsi, r8

<span class="csharp-green">// if (depth == closure.word.Length + closure.maxEdits)</span>
<span class="csharp-green">// {</span>
<span class="csharp-green">//     return;</span>
<span class="csharp-green">// }</span>
    <span class="csharp-green">// Load address of word from closure</span>
    L0021: mov rdx, [rsi]
    <span class="csharp-green">// Load length from word</span>
    L0024: mov edx, [rdx+<span class="csharp-teal">8</span>]
    <span class="csharp-green">// Expand length into 64 bit</span>
    L0027: movsxd rdx, edx
    <span class="csharp-green">// Load maxEdits</span>
    L002a: mov eax, [rsi+<span class="csharp-teal">8</span>]
    <span class="csharp-green">// Copy maxEdits</span>
    L002d: mov r8d, eax
    <span class="csharp-green">// closure.word.Length + closure.maxEdits</span>
    L0030: add rdx, r8
    <span class="csharp-green">// Copy and expand depth into 64 bit</span>
    L0033: movsxd r8, edi
    <span class="csharp-green">// if (depth == closure.word.Length + closure.maxEdits)</span>
    L0036: cmp rdx, r8
    L0039: jne <span class="csharp-navy">short</span> L004c
    <span class="csharp-green">// return;</span>
    L003b: add rsp, <span class="csharp-teal">0x58</span>
    L003f: pop rbx
    L0040: pop rbp
    L0041: pop rsi
    L0042: pop rdi
    L0043: pop r12
    L0045: pop r13
    L0047: pop r14
    L0049: pop r15
    L004b: ret

<span class="csharp-green">// var firstChild = closure.graph.FirstChildEdgeIndex[currentNode];</span>
<span class="csharp-green">// var lastChild = closure.graph.FirstChildEdgeIndex[currentNode + 1];</span>
    <span class="csharp-green">// Load the address of graph from closure</span>
    L004c: mov rdx, [rsi+<span class="csharp-teal">0x10</span>]
    <span class="csharp-green">// Load the address of FirstChildEdgeIndex from graph</span>
    L0050: mov rdx, [rdx+<span class="csharp-teal">0x10</span>]
    <span class="csharp-green">// Copy FirstChildEdgeIndex</span>
    L0054: mov r8, rdx
    L0057: cmp ecx, [r8+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on FirstChildEdgeIndex vs currentNode</span>
    L005b: jae L0334 <span class="csharp-green">// IndexOutOfRangeException </span>

    <span class="csharp-green">// Copy currentNode</span>
    L0061: movsxd r9, ecx
    <span class="csharp-green">// var firstChild = closure.graph.FirstChildEdgeIndex[currentNode];</span>
    L0064: mov ebx, [r8+r9*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>]
    <span class="csharp-green">// currentNode + 1</span>
    L0069: lea r8d, [rcx+<span class="csharp-teal">1</span>]
    L006d: cmp r8d, [rdx+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on FirstChildEdgeIndex vs currentNode + 1</span>
    L0071: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>

    <span class="csharp-green">// currentNode + 1 // Isn't this unnecessary?</span>
    L0077: inc ecx
    <span class="csharp-green">// Expand currentNode + 1 into 64 bits</span>
    L0079: movsxd rcx, ecx
    <span class="csharp-green">// var lastChild = closure.graph.FirstChildEdgeIndex[currentNode + 1];</span>
    L007c: mov ebp, [rdx+rcx*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>]

<span class="csharp-green">// var from = depth - (int)closure.maxEdits;</span>
<span class="csharp-green">// if (from &lt; 0)</span>
<span class="csharp-green">// {</span>
<span class="csharp-green">//     from = 0;</span>
<span class="csharp-green">// }</span>
<span class="csharp-green">// from++;</span>
    <span class="csharp-green">// Copy depth</span>
    L0080: mov r14d, edi
    <span class="csharp-green">// var from = depth - (int)closure.maxEdits;</span>
    L0083: sub r14d, eax
    <span class="csharp-green">// if (from &lt; 0)</span>
    L0086: test r14d, r14d
    L0089: jge <span class="csharp-navy">short</span> L008e
    <span class="csharp-green">// from = 0;</span>
    L008b: <span class="csharp-navy">xor</span> r14d, r14d
    <span class="csharp-green">// from++;</span>
    L008e: inc r14d

<span class="csharp-green">// var to = Math.Min(closure.word.Length + 1, depth + closure.maxEdits + 2);</span>
    L0091: mov rcx, [rsi] <span class="csharp-green">// word</span>
    <span class="csharp-green">// Load word.Length</span>
    L0094: mov ecx, [rcx+<span class="csharp-teal">8</span>]
    <span class="csharp-green">// word.length + 1</span>
    L0097: inc ecx
    <span class="csharp-green">// Expand word.length + 1 into 64 bit</span>
    L0099: movsxd r15, ecx
    <span class="csharp-green">// Expand depth into 64 bit</span>
    L009c: movsxd rcx, edi
    <span class="csharp-green">// Copy maxEdits</span>
    L009f: mov edx, eax
    <span class="csharp-green">// to = depth + closure.maxEdits + 2</span>
    L00a1: lea r12, [rcx+rdx+<span class="csharp-teal">2</span>]
    L00a6: cmp r15, r12
    <span class="csharp-green">// Math.Min</span>
    L00a9: jle <span class="csharp-navy">short</span> L00ad
    L00ab: jmp <span class="csharp-navy">short</span> L00b0
    <span class="csharp-green">// to = word.length + 1</span>
    L00ad: mov r12, r15

<span class="csharp-green">// var previousCharacter = depth &gt; 0 ? closure.builder[depth - 1] : (char)0;</span>
    <span class="csharp-green">// depth &gt; 0 ? </span>
    L00b0: test edi, edi
    L00b2: jg <span class="csharp-navy">short</span> L00b9
    <span class="csharp-green">// var previousCharacter = (char)0;</span>
    L00b4: <span class="csharp-navy">xor</span> r15d, r15d
    L00b7: jmp <span class="csharp-navy">short</span> L00ca
    <span class="csharp-green">// Load address of builder from closure</span>
    L00b9: mov rcx, [rsi+<span class="csharp-teal">0x20</span>] <span class="csharp-green">// builder</span>
    <span class="csharp-green">// depth - 1</span>
    L00bd: lea edx, [rdi<span class="csharp-teal">-1</span>]
    L00c0: cmp [rcx], ecx <span class="csharp-green">// I don't know what this does</span>
    L00c2: call System.Text.StringBuilder.get_Chars(Int32)
    <span class="csharp-green">// var previousCharacter = closure.builder[depth - 1];</span>
    L00c7: mov r15d, eax
    <span class="csharp-green">// Expand previousCharacter into 64 bit</span>
    L00ca: movzx r15d, r15w
    <span class="csharp-green">// Store previousCharacter on the stack</span>
    L00ce: mov [rsp+<span class="csharp-teal">0x50</span>], r15d

<span class="csharp-green">// var previousRow = closure.matrix[depth];</span>
<span class="csharp-green">// var currentRow = closure.matrix[depth + 1];</span>
    <span class="csharp-green">// Load address of matrix from closure</span>
    L00d3: mov rcx, [rsi+<span class="csharp-teal">0x18</span>] <span class="csharp-green">// matrix</span>
    <span class="csharp-green">// Copy of matrix</span>
    L00d7: mov rdx, rcx
    L00da: cmp edi, [rdx+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on matrix.Length vs depth</span>
    L00dd: jae L0334 <span class="csharp-green">// IndexOutOfRangeException </span>
    <span class="csharp-green">// Expand depth into 64 bit</span>
    L00e3: movsxd r8, edi
    <span class="csharp-green">// var previousRow = closure.matrix[depth];</span>
    L00e6: mov r13, [rdx+r8*<span class="csharp-teal">8</span>+<span class="csharp-teal">0x10</span>]
    <span class="csharp-green">// Depth + 1</span>
    L00eb: lea eax, [rdi+<span class="csharp-teal">1</span>]
    L00ee: cmp eax, [rcx+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on matrix.Length vs depth + 1</span>
    L00f1: jae L0334 <span class="csharp-green">// IndexOutOfRangeException </span>
    <span class="csharp-green">// Store depth + 1 on the stack</span>
    L00f7: mov [rsp+<span class="csharp-teal">0x34</span>], eax <span class="csharp-green">// depth + 1</span>
    <span class="csharp-green">// Expand depth + 1 into 64 bit</span>
    L00fb: movsxd rdx, eax
    <span class="csharp-green">// var currentRow = closure.matrix[depth + 1];</span>
    L00fe: mov r9, [rcx+rdx*<span class="csharp-teal">8</span>+<span class="csharp-teal">0x10</span>]
    <span class="csharp-green">// Store currentRow on the stack</span>
    L0103: mov [rsp+<span class="csharp-teal">0x28</span>], r9 <span class="csharp-green">// currentRow</span>

<span class="csharp-green">// Store lastChild on the stack</span>
L0108: mov [rsp+<span class="csharp-teal">0x54</span>], ebp <span class="csharp-green">// lastChild</span>

<span class="csharp-green">// for (var childEdge = firstChild; childEdge &lt; lastChild; childEdge++)</span>
    L010c: cmp ebx, ebp
    L010e: jae L0323

<span class="csharp-green">// *****  *****  *****  *****</span>
<span class="csharp-green">// Begin outer loop</span>
<span class="csharp-green">// *****  *****  *****  *****</span>

<span class="csharp-green">// var any = false;</span>
    L0114: <span class="csharp-navy">xor</span> r10d, r10d
    <span class="csharp-green">// Store any on the stack</span>
    L0117: mov [rsp+<span class="csharp-teal">0x4c</span>], r10d

<span class="csharp-green">// var currentCharacter = closure.graph.EdgeCharacters[childEdge];</span>
    <span class="csharp-green">// Load the address of graph from closure</span>
    L011c: mov rcx, [rsi+<span class="csharp-teal">0x10</span>] <span class="csharp-green">// graph</span>
    <span class="csharp-green">// Load the address of EdgeCharacters from graph</span>
    L0120: mov rcx, [rcx+<span class="csharp-teal">8</span>]
    L0124: cmp ebx, [rcx+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on EdgeCharacters.Length vs childEdge</span>
    L0127: jae L0334 <span class="csharp-green">// IndexOutOfRangeException </span>
    <span class="csharp-green">// Expand childEdge into 64 bits</span>
    L012d: movsxd rdx, ebx
    <span class="csharp-green">// var currentCharacter = closure.graph.EdgeCharacters[childEdge];</span>
    L0130: movzx r11d, word ptr [rcx+rdx*<span class="csharp-teal">2</span>+<span class="csharp-teal">0x10</span>]

<span class="csharp-green">// closure.builder[depth] = currentCharacter;</span>
    <span class="csharp-green">// Load the address of builder from closure</span>
    L0136: mov rcx, [rsi+<span class="csharp-teal">0x20</span>] <span class="csharp-green">// builder</span>
    <span class="csharp-green">// Copy depth into function parameter</span>
    L013a: mov edx, edi
    <span class="csharp-green">// Store currentCharacter on the stack</span>
    L013c: mov [rsp+<span class="csharp-teal">0x48</span>], r11d <span class="csharp-green">// currentCharacter</span>
    <span class="csharp-green">// Copy currentCharacter into function parameter</span>
    L0141: mov r8d, r11d
    L0144: cmp [rcx], ecx <span class="csharp-green">// I don't know what this does</span>
    L0146: call System.Text.StringBuilder.set_Chars(Int32, Char)

<span class="csharp-green">//var calculatedCost = depth + 1;</span>
    <span class="csharp-green">// Load depth + 1 from the stack</span>
    L014b: mov eax, [rsp+<span class="csharp-teal">0x34</span>] <span class="csharp-green">// depth + 1</span>
    <span class="csharp-green">// Copy calculatedCost</span>
    L014f: mov ecx, eax

<span class="csharp-green">// var previousRowEntry = previousRow[from - 1];</span>
    <span class="csharp-green">// from -1</span>
    L0151: lea r8d, [r14<span class="csharp-teal">-1</span>]
    L0155: mov edx, [r13+<span class="csharp-teal">8</span>] <span class="csharp-green">// previousRow.Length</span>
    L0159: cmp r8d, edx <span class="csharp-green">// Boundary check on previousRow vs from - 1</span>
    L015c: jae L0334 <span class="csharp-green">// IndexOutOfRangeException </span>
    <span class="csharp-green">// Expand into 64 bits</span>
    L0162: movsxd r8, r8d
    <span class="csharp-green">// var previousRowEntry = previousRow[from - 1];</span>
    <span class="csharp-green">// Is actually previousRowPreviousEntry</span>
    L0165: mov r8d, [r13+r8*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>] <span class="csharp-green">// previousRow</span>

<span class="csharp-green">// var targetCharacter = (char)0;</span>
    <span class="csharp-green">// Is actually setting previousTargetCharacter</span>
    L016a: <span class="csharp-navy">xor</span> r9d, r9d


<span class="csharp-green">// for (var i = from; i &lt; to; i++)</span>
    <span class="csharp-green">// i = from</span>
    L016d: mov r10d, r14d
    <span class="csharp-green">// i = from // Expanded to 64 bit</span>
    L0170: movsxd r11, r14d
    <span class="csharp-green">// i &lt; to</span>
    L0173: cmp r11, r12
    L0176: jge L0248

<span class="csharp-green">// *****  *****  *****  *****</span>
<span class="csharp-green">// Begin inner loop</span>
<span class="csharp-green">// *****  *****  *****  *****</span>

<span class="csharp-green">// targetCharacter = closure.word[i - 1];</span>
    <span class="csharp-green">// Load the address of word from closure</span>
    L017c: mov r11, [rsi] <span class="csharp-green">// word</span>
    <span class="csharp-green">// i - 1</span>
    L017f: lea ebp, [r10<span class="csharp-teal">-1</span>]
    L0183: cmp ebp, [r11+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on word vs i - 1</span>
    L0187: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
    <span class="csharp-green">// Expand i - 1 into 64 bit</span>
    L018d: movsxd rbp, ebp
    <span class="csharp-green">// targetCharacter = closure.word[i - 1];</span>
    L0190: movzx r11d, word ptr [r11+rbp*<span class="csharp-teal">2</span>+<span class="csharp-teal">0xc</span>]

<span class="csharp-green">// previousRowEntry = previousRow[i];</span>
    L0196: cmp r10d, edx <span class="csharp-green">// Boundary check on previousRow vs i</span>
    L0199: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
    <span class="csharp-green">// Expand i into 64 bit</span>
    L019f: movsxd rbp, r10d
    <span class="csharp-green">// previousRow[i]</span>
    L01a2: mov eax, [r13+rbp*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>] <span class="csharp-green">// previousRow</span>

<span class="csharp-green">// if (currentCharacter == targetCharacter)</span>
    <span class="csharp-green">// Load currentCharacter from the stack</span>
    L01a7: mov r15d, [rsp+<span class="csharp-teal">0x48</span>] <span class="csharp-green">// currentCharacter</span>
    L01ac: cmp r15d, r11d
    L01af: jne <span class="csharp-navy">short</span> L01b6
    L01b1: mov ecx, r8d <span class="csharp-green">// previousRowPreviousEntry</span>
    L01b4: jmp <span class="csharp-navy">short</span> L0206
<span class="csharp-green">// else</span>
    <span class="csharp-green">// if (previousRowEntry &lt; calculatedCost)</span>
    <span class="csharp-green">//     calculatedCost = previousRowEntry;</span>
        L01b6: cmp eax, ecx
        L01b8: jge <span class="csharp-navy">short</span> L01bc
        L01ba: mov ecx, eax

    <span class="csharp-green">// if (targetCharacter == previousCharacter &amp;&amp; previousTargetCharacter == currentCharacter)</span>
    <span class="csharp-green">//     previousRowPreviousEntry = closure.matrix[depth - 1][i - 2];</span>
        L01bc: cmp r11d, [rsp+<span class="csharp-teal">0x50</span>] <span class="csharp-green">// targetCharacter vs previousCharacter</span>
        L01c1: jne <span class="csharp-navy">short</span> L01fc
        L01c3: cmp r9d, r15d <span class="csharp-green">// previousTargetCharacter vs currentCharacter</span>
        L01c6: jne <span class="csharp-navy">short</span> L01fc
        <span class="csharp-green">// Load address of matrix from closure</span>
        L01c8: mov r8, [rsi+<span class="csharp-teal">0x18</span>] <span class="csharp-green">// matrix</span>
        <span class="csharp-green">// depth - 1</span>
        L01cc: lea r9d, [rdi<span class="csharp-teal">-1</span>]
        L01d0: cmp r9d, [r8+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check matrix vs depth - 1</span>
        L01d4: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
        <span class="csharp-green">// depth - 1</span>
        L01da: lea r9d, [rdi<span class="csharp-teal">-1</span>] <span class="csharp-green">// This seems useless</span>
        <span class="csharp-green">// Expand into 64 bit</span>
        L01de: movsxd r9, r9d
        <span class="csharp-green">// Load address of closure.matrix[depth - 1] array</span>
        L01e1: mov r8, [r8+r9*<span class="csharp-teal">8</span>+<span class="csharp-teal">0x10</span>]
        <span class="csharp-green">// i - 2</span>
        L01e6: lea r9d, [r10<span class="csharp-teal">-2</span>]
        L01ea: cmp r9d, [r8+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check closure.matrix[depth - 1] vs i - 2</span>
        L01ee: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
        <span class="csharp-green">// Expand into 64 bit</span>
        L01f4: movsxd r9, r9d
        <span class="csharp-green">// previousRowPreviousEntry = closure.matrix[depth - 1][i - 2];</span>
        L01f7: mov r8d, [r8+r9*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>] <span class="csharp-green">// previousRowPreviousEntry</span>

    <span class="csharp-green">// if (previousRowPreviousEntry &lt; calculatedCost)</span>
    <span class="csharp-green">//     calculatedCost = previousRowPreviousEntry;</span>
        L01fc: cmp r8d, ecx
        L01ff: jge <span class="csharp-navy">short</span> L0204
        L0201: mov ecx, r8d

    <span class="csharp-green">// calculatedCost++;</span>
    L0204: inc ecx


<span class="csharp-green">// if (calculatedCost &lt;= 0)</span>
<span class="csharp-green">//     any = true;</span>
    L0206: test ecx, ecx
    L0208: jg <span class="csharp-navy">short</span> L0215
    <span class="csharp-green">// Write true into register</span>
    L020a: mov r8d, <span class="csharp-teal">1</span>
    <span class="csharp-green">// any = true;</span>
    L0210: mov [rsp+<span class="csharp-teal">0x4c</span>], r8d <span class="csharp-green">// any</span>

<span class="csharp-green">// currentRow[i] = calculatedCost;</span>
    <span class="csharp-green">// Load the address of currentRow</span>
    L0215: mov r9, [rsp+<span class="csharp-teal">0x28</span>]
    L021a: cmp r10d, [r9+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on currentRow</span>
    L021e: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
    L0224: mov [rsp+<span class="csharp-teal">0x28</span>], r9 <span class="csharp-green">// Is this useless?</span>
    <span class="csharp-green">// currentRow[i] = calculatedCost;</span>
    L0229: mov [r9+rbp*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>], ecx

<span class="csharp-green">// i++;</span>
    L022e: inc r10d
<span class="csharp-green">// i &lt; to</span>
    <span class="csharp-green">// Copy and expand to 64 bits</span>
    L0231: movsxd rbp, r10d
    L0234: cmp rbp, r12 <span class="csharp-green">// used in L0242</span>

<span class="csharp-green">// Store currentCharacter to the stack</span>
<span class="csharp-green">// This is useless</span>
L0237: mov [rsp+<span class="csharp-teal">0x48</span>], r15d <span class="csharp-green">// currentCharacter</span>

<span class="csharp-green">// var previousRowPreviousEntry = previousRowEntry;</span>
    L023c: mov r8d, eax
<span class="csharp-green">// var previousTargetCharacter = targetCharacter;</span>
    L023f: mov r9d, r11d
<span class="csharp-green">// *****  *****  *****  *****</span>
L0242: jl L017c <span class="csharp-green">// Iterate inner loop</span>
<span class="csharp-green">// *****  *****  *****  *****</span>

<span class="csharp-green">// if (!any)</span>
L0248: cmp dword ptr [rsp+<span class="csharp-teal">0x4c</span>], <span class="csharp-teal">0</span>
<span class="csharp-green">// continue;</span>
L024d: je L0311

<span class="csharp-green">// var nextNode = closure.graph.EdgeToNodeIndex[childEdge];</span>
    <span class="csharp-green">// Load address of graph from closure</span>
    L0253: mov r8, [rsi+<span class="csharp-teal">0x10</span>] <span class="csharp-green">// graph</span>
    <span class="csharp-green">// Load address of EdgeToNodeIndex from graph</span>
    L0257: mov r8, [r8+<span class="csharp-teal">0x18</span>]
    L025b: cmp ebx, [r8+<span class="csharp-teal">8</span>] <span class="csharp-green">// Boundary check on EdgeToNodeIndex vs childEdge</span>
    L025f: jae L0334 <span class="csharp-green">// IndexOutOfRangeException</span>
    <span class="csharp-green">// Expand childEdge to 64 bit</span>
    L0265: movsxd rdx, ebx
    <span class="csharp-green">// closure.graph.EdgeToNodeIndex[childEdge]</span>
    L0268: mov ebp, [r8+rdx*<span class="csharp-teal">4</span>+<span class="csharp-teal">0x10</span>]

<span class="csharp-green">//if (nextNode &lt; 0)</span>
    L026d: test ebp, ebp
    L026f: jge L0303

<span class="csharp-green">// nextNode = -nextNode;</span>
    L0275: neg ebp

<span class="csharp-green">// if (depth &gt;= closure.word.Length - closure.maxEdits - 1 &amp;&amp; calculatedCost &lt;= 0)</span>
    <span class="csharp-green">// Load address of word from closure</span>
    L0277: mov r8, [rsi] <span class="csharp-green">// word</span>
    <span class="csharp-green">// Load word.Length</span>
    L027a: mov r8d, [r8+<span class="csharp-teal">8</span>]
    <span class="csharp-green">// Expand to 64 bit</span>
    L027e: movsxd r8, r8d
    <span class="csharp-green">// Load maxEdits from graph</span>
    L0281: mov edx, [rsi+<span class="csharp-teal">8</span>] <span class="csharp-green">// maxEdits</span>
    <span class="csharp-green">// closure.word.Length - closure.maxEdits</span>
    L0284: sub r8, rdx
    <span class="csharp-green">// closure.word.Length - closure.maxEdits - 1</span>
    L0287: dec r8
    <span class="csharp-green">// expand to 64 bit</span>
    L028a: movsxd rdx, edi
    <span class="csharp-green">// depth &gt;= closure.word.Length - closure.maxEdits - 1</span>
    L028d: cmp r8, rdx
    L0290: jg <span class="csharp-navy">short</span> L0303
    <span class="csharp-green">// calculatedCost &lt;= 0</span>
    L0292: test ecx, ecx
    L0294: jg <span class="csharp-navy">short</span> L0303
    <span class="csharp-green">// closure.results.Add(new SuggestItem(closure.builder.ToString(0, depth + 1), 0));</span>
        <span class="csharp-green">// Load address of results from closure</span>
        L0296: mov r15, [rsi+<span class="csharp-teal">0x28</span>] <span class="csharp-green">// results</span>
        <span class="csharp-green">// Load address of builder from closure</span>
        L029a: mov rcx, [rsi+<span class="csharp-teal">0x20</span>] <span class="csharp-green">// builder</span>
        <span class="csharp-green">// Load depth + 1 from the stack</span>
        L029e: mov r8d, [rsp+<span class="csharp-teal">0x34</span>] <span class="csharp-green">// depth + 1</span>
        <span class="csharp-green">// Set function argument to 0</span>
        L02a3: <span class="csharp-navy">xor</span> edx, edx
        L02a5: cmp [rcx], ecx <span class="csharp-green">// I don't know what this does</span>
        <span class="csharp-green">// closure.builder.ToString(0, depth + 1)</span>
        L02a7: call System.Text.StringBuilder.ToString(Int32, Int32)

        <span class="csharp-green">// I think this is moving the result of the ToString into the function argument slot</span>
        L02ac: mov rdx, rax
        <span class="csharp-green">// I don't really care what's going on down here.</span>
        <span class="csharp-green">// closure.results.Add(new SuggestItem(...)</span>
        L02af: <span class="csharp-navy">xor</span> eax, eax
        L02b1: inc dword ptr [r15+<span class="csharp-teal">0x14</span>]
        L02b5: mov rcx, [r15+<span class="csharp-teal">8</span>]
        L02b9: mov r8d, [r15+<span class="csharp-teal">0x10</span>]
        L02bd: mov r9d, [rcx+<span class="csharp-teal">8</span>]
        L02c1: cmp r9d, r8d
        L02c4: jbe <span class="csharp-navy">short</span> L02ea
        L02c6: lea eax, [r8+<span class="csharp-teal">1</span>]
        L02ca: mov [r15+<span class="csharp-teal">0x10</span>], eax
        L02ce: movsxd rax, r8d
        L02d1: shl rax, <span class="csharp-teal">4</span>
        L02d5: lea r15, [rcx+rax+<span class="csharp-teal">0x10</span>]
        L02da: mov rcx, r15
        L02dd: call <span class="csharp-teal">0x00007ff9730aa9c0</span>
        L02e2: <span class="csharp-navy">xor</span> ecx, ecx
        L02e4: mov [r15+<span class="csharp-teal">8</span>], rcx
        L02e8: jmp <span class="csharp-navy">short</span> L0303
        L02ea: lea rcx, [rsp+<span class="csharp-teal">0x38</span>]
        L02ef: mov [rcx], rdx
        L02f2: mov [rcx+<span class="csharp-teal">8</span>], rax
        L02f6: mov rcx, r15
        L02f9: lea rdx, [rsp+<span class="csharp-teal">0x38</span>]
        L02fe: call System.Collections.Generic.List`<span class="csharp-teal">1</span>[[PerformanceTesting.SuggestItem, _]].AddWithResize(PerformanceTesting.SuggestItem)

<span class="csharp-green">// Load depth + 1 from the stack</span>
L0303: mov edx, [rsp+<span class="csharp-teal">0x34</span>] <span class="csharp-green">// depth + 1</span>
<span class="csharp-green">// Prepare function parameter nextNode</span>
L0307: mov ecx, ebp
<span class="csharp-green">// Prepare function parameter closure</span>
L0309: mov r8, rsi
<span class="csharp-green">// Recurse</span>
L030c: call PerformanceTesting.Dawg11.&lt;Lookup&gt;g__Recurse|<span class="csharp-teal">3</span>_0(Int32, Int32, ClosureVariable ByRef)

<span class="csharp-green">// childEdge++</span>
L0311: inc ebx
L0313: mov ebp, [rsp+<span class="csharp-teal">0x54</span>] <span class="csharp-green">// lastChild</span>
L0317: cmp ebx, ebp
L0319: mov [rsp+<span class="csharp-teal">0x54</span>], ebp
<span class="csharp-green">// *****  *****  *****  *****</span>
L031d: jb L0114 <span class="csharp-green">// Iterate outer loop</span>
<span class="csharp-green">// *****  *****  *****  *****</span>

<span class="csharp-green">// return;</span>
L0323: add rsp, <span class="csharp-teal">0x58</span>
L0327: pop rbx
L0328: pop rbp
L0329: pop rsi
L032a: pop rdi
L032b: pop r12
L032d: pop r13
L032f: pop r14
L0331: pop r15
L0333: ret
<span class="csharp-green">// IndexOutOfRangeException </span>
L0334: call <span class="csharp-teal">0x00007ff9731fc590</span>
L0339: int3
</code></pre>
    </details>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 7</h3>
      <p>Reducing indirection</p>
    </header>
    <p>
      closure.graph.EdgeCharacters and closure.graph.EdgeToNodeIndex are retrieved inside the loops.
      It's easy enough to store them directly in closure instead.
    </p>
    <details>
      <summary><h4>diff Dawg16.cs Dawg17.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  {
      <span class="csharp-navy">this</span>.word = word;
      <span class="csharp-navy">this</span>.maxEdits = maxEdits;
<span class="diff-remove">-     <span class="csharp-navy">this</span>.graph = graph;</span>
      <span class="csharp-navy">this</span>.matrix = matrix;
      <span class="csharp-navy">this</span>.builder = builder;
      <span class="csharp-navy">this</span>.results = results;
<span class="diff-add">+</span>
<span class="diff-add">+     EdgeCharacters = graph.EdgeCharacters;</span>
<span class="diff-add">+     FirstChildEdgeIndex = graph.FirstChildEdgeIndex;</span>
<span class="diff-add">+     EdgeToNodeIndex = graph.EdgeToNodeIndex;</span>
  }

  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">string</span> word;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint maxEdits;
<span class="diff-remove">- <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> CompressedSparseRowGraph graph;</span>
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> StringBuilder builder;
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;
<span class="diff-add">+</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>[] EdgeCharacters;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint[] FirstChildEdgeIndex;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[] EdgeToNodeIndex;</span>
}

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">firstChild</span> = closure.graph.FirstChildEdgeIndex[currentNode];</span>
<span class="diff-remove">- <span class="csharp-navy">var</span> lastChild = closure.graph.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> firstChild = closure.FirstChildEdgeIndex[currentNode];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> lastChild = closure.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];</span>

<span class="diff-break">@@</span>
<span class="diff-remove">-     <span class="cshar-navy">var</span> <span class="cshar-navy">currentCharacter</span> = closure.graph.EdgeCharacters[childEdge];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[childEdge];</span>

<span class="diff-break">@@</span>
<span class="diff-remove">-     <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = closure.graph.EdgeToNodeIndex[childEdge];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> nextNode = closure.EdgeToNodeIndex[childEdge];</span>
</code></pre>
    </details>
    <p>
      718.0 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Removing redundant instructions - part 1</h3>
    </header>
    <p>
      Once we reach the loop, depth is only accessed with an offset. The most common of these is +1, so why not just do that work once?
    </p>
    <details>
      <summary><h4>diff Dawg17.cs Dawg18.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">previousRow</span> = closure.matrix[depth];
<span class="diff-remove">- <span class="csharp-navy">var</span> currentRow = closure.matrix[depth + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+ ++depth;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> currentRow = closure.matrix[depth];</span>

  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
  {
      <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[childEdge];
<span class="diff-remove">-     closure.builder[depth] = currentCharacter;</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> calculatedCost = depth + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     closure.builder[depth - <span class="csharp-teal">1</span>] = currentCharacter;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> calculatedCost = depth;</span>
      <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
      <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
<span class="diff-break">@@</span>
              <span class="cshar-navy">if</span> (<span class="cshar-navy">targetCharacter</span> == previousCharacter
                  &amp;&amp; previousTargetCharacter == currentCharacter)
              {
<span class="diff-remove">-                 previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">1</span>][i - <span class="csharp-teal">2</span>];</span>
<span class="diff-add">+                 previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">2</span>][i - <span class="csharp-teal">2</span>];</span>
              }

              <span class="csharp-navy">if</span> (previousRowPreviousEntry &lt; calculatedCost)
<span class="diff-break">@@</span>
      <span class="cshar-navy">if</span> (<span class="cshar-navy">nextNode</span> &lt; 0)
      {
          nextNode = -nextNode;
<span class="diff-remove">-         <span class="csharp-navy">if</span> (depth &gt;= closure.word.Length - closure.maxEdits - <span class="csharp-teal">1</span></span>
<span class="diff-add">+         <span class="csharp-navy">if</span> (depth &gt;= closure.word.Length - closure.maxEdits</span>
              &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
          {
<span class="diff-remove">-             closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth + <span class="csharp-teal">1</span>), <span class="csharp-teal">0</span>));</span>
<span class="diff-add">+             closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth), <span class="csharp-teal">0</span>));</span>
          }
      }

<span class="diff-remove">-     Recurse(nextNode, depth + <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+     Recurse(nextNode, depth, <span class="csharp-navy">ref</span> closure);</span>
  }
</code></pre>
    </details>
    <p>
      Ok, this one I just can't explain.
      The resulting assembly successfully re-uses the incremented depth while the old version cache it and has to store/load it when used.
      It might be either an alignment issue, a cpu pipeline mismatch, or something weirder.
      I would use Intel VTune, but I'm not aware of a C# capable equivalent for AMD.
    </p>
    <p>
      755.68 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 8</h3>
      <p>Reducing boundary checks.</p>
    </header>
    <p>
      Not far from the top I noticed two consecutive boundary checks on FirstChildEdgeIndex.
      I tried swapping them to do the currentNode + 1 check first and eliminate the second check - it didn't work.
      Still a positive change in the Asm so I kept it.
    </p>
    <p>
      I also noticed maxEdits was being cast to an int or even causing <i>int + uint -&gt; long</i> conversions, so I changed it from uint to int in ClosureVariable.
    </p>
    <details>
      <summary><h4>diff Dawg18.cs Dawg19.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">string</span> <span class="cshar-navy">word</span>, <span class="cshar-navy">uint</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">CompressedSparseRowGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>[][] <span class="cshar-navy">matrix</span>, <span class="cshar-navy">StringBuilder</span> <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()
  {
      <span class="csharp-navy">this</span>.word = word;
<span class="diff-remove">-     <span class="csharp-navy">this</span>.maxEdits = maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">this</span>.maxEdits = (<span class="csharp-navy">int</span>)maxEdits;</span>
      <span class="csharp-navy">this</span>.matrix = matrix;
<span class="diff-break">@@</span>
  <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">string</span> <span class="cshar-navy">word</span>;
<span class="diff-remove">- <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint maxEdits;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> maxEdits;</span>
  <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;
<span class="diff-break">@@</span>
      <span class="cshar-navy">return</span>;
  }

<span class="diff-remove">- <span class="csharp-navy">var</span> firstChild = closure.FirstChildEdgeIndex[currentNode];</span>
<span class="diff-remove">- <span class="csharp-navy">var</span> lastChild = closure.FirstChildEdgeIndex[currentNode + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> firstChild = fIndex[currentNode];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> lastChild = fIndex[currentNode + <span class="csharp-teal">1</span>];</span>

<span class="diff-remove">- <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - (<span class="csharp-navy">int</span>)closure.maxEdits;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - closure.maxEdits;</span>
  <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &lt; <span class="csharp-teal">0</span>)
  {
      <span class="csharp-navy">from</span> = <span class="csharp-teal">0</span>;
<span class="diff-break">@@</span>

<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">to</span> = Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> to = (<span class="csharp-navy">long</span>)Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);</span>
  <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;
</code></pre>
    </details>
    <p>
      Well now I'm really confused.
      Another regression when the assembly has only gotten better.
    </p>
    <p>
      779.3 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 9</h3>
      <p>Reducing boundary checks, for real this time.</p>
    </header>
    <p>
      Hint: pointers don't check for out of range boundary conditions.
    </p>
    <p>
      While I was at it, I converted matrix to a one-dimensional array.
      It makes much more sense when we're using pointers.
    </p>
    <details>
      <summary><h4>diff Dawg19.cs Dawg20.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
      <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">string</span> <span class="cshar-navy">word</span>;
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> maxEdits;
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[][] matrix;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> StringBuilder builder;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* matrix;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* builder;</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;

<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>[] EdgeCharacters;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint[] FirstChildEdgeIndex;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>[] EdgeToNodeIndex;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* EdgeCharacters;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint* FirstChildEdgeIndex;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* EdgeToNodeIndex;</span>
  }

  <span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="cshar-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
  {
<span class="diff-remove">-     <span class="csharp-navy">var</span> builder = <span class="csharp-navy">new</span> StringBuilder(word.Length + (<span class="csharp-navy">int</span>)maxEdits);</span>
<span class="diff-remove">-     builder.Append(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(<span class="csharp-brown">' '</span>, word.Length + (<span class="csharp-navy">int</span>)maxEdits));</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> builderLength = word.Length + (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> builder = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[builderLength];</span>
<span class="diff-add">+     <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; builderLength; i++)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         builder[i] = <span class="csharp-brown">' '</span>;</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+</span>
      <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

<span class="diff-remove">-     <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + maxEdits + <span class="csharp-teal">1</span>][];</span>
<span class="diff-remove">-     <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix.Length; i++)</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> rowLength = word.Length + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> rowCount = rowLength + (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">int</span>[rowLength * rowCount];</span>
<span class="diff-add">+     <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowCount; i++)</span>
      {
<span class="diff-remove">-         matrix[i] = <span class="csharp-navy">new</span> <span class="csharp-navy">int</span>[word.Length + <span class="csharp-teal">1</span>];</span>
<span class="diff-remove">-         matrix[i][<span class="csharp-teal">0</span>] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+</span>
<span class="diff-add">+         matrix[i * rowLength] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>

          <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
          <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
          {
<span class="diff-remove">-             matrix[i][stripeEnd] = <span class="csharp-teal">0</span>;</span>
<span class="diff-add">+             matrix[i * rowLength + stripeEnd] = <span class="csharp-teal">0</span>;</span>
          }
      }

<span class="diff-remove">-     <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; matrix[<span class="csharp-teal">0</span>].Length; i++)</span>
<span class="diff-add">+     <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowLength; i++)</span>
      {
<span class="diff-remove">-         matrix[<span class="csharp-teal">0</span>][i] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+         matrix[i] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
      }

      <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, _graph, matrix, builder, results);
<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">to</span> = (<span class="csharp-navy">long</span>)Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
      <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;

<span class="diff-remove">-     <span class="csharp-navy">var</span> previousRow = closure.matrix[depth];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> rowLength = closure.word.Length + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;</span>
      ++depth;
<span class="diff-remove">-     <span class="csharp-navy">var</span> currentRow = closure.matrix[depth];</span>

      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
      {
<span class="diff-break">@@</span>
                  <span class="cshar-navy">if</span> (<span class="cshar-navy">targetCharacter</span> == previousCharacter
                      &amp;&amp; previousTargetCharacter == currentCharacter)
                  {
<span class="diff-remove">-                     previousRowPreviousEntry = closure.matrix[depth - <span class="csharp-teal">2</span>][i - <span class="csharp-teal">2</span>];</span>
<span class="diff-add">+                     previousRowPreviousEntry = previousRow[i - closure.word.Length - <span class="csharp-teal">3</span>];</span>
                  }

                  <span class="csharp-navy">if</span> (previousRowPreviousEntry &lt; calculatedCost)
<span class="diff-break">@@</span>
              <span class="cshar-navy">if</span> (<span class="cshar-navy">depth</span> &gt;= closure.word.Length - closure.maxEdits
                  &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
              {
<span class="diff-remove">-                 closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(closure.builder.ToString(<span class="csharp-teal">0</span>, depth), <span class="csharp-teal">0</span>));</span>
<span class="diff-add">+                 closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, depth), <span class="csharp-teal">0</span>));</span>
              }
          }
</code></pre>
    </details>
    <p>
      Finally, an improvement.
    </p>
    <p>
      673.7 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Removing redundant instructions - part 2</h3>
    </header>
    <p>
      Because we're in 64-bit mode, memory indexing operations operate with 64 bit addresses (duh).
      Many of our indexing values are int.
      Converting them to long removes some useless movxsd instructions.
    </p>
    <p>
      For this to work, I've changed some variables types from int to long.
    </p>
    <p>
      Conversely, some other values which aren't used for indexing and remain as int, are used either in arithmetic or comparisons to our newly promoted longs.
      Casting the long to an int is free in terms of assembly, the 32 bit version of the same register will be used instead.
      This adds some casts to (int) in a bunch of places.
    </p>
    <details>
      <summary><h4>diff Dawg20.cs Dawg21.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">string</span> <span class="cshar-navy">word</span>, <span class="cshar-navy">uint</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">PointerGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>* <span class="cshar-navy">matrix</span>, <span class="cshar-navy">char</span>* <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()</span>
<span class="diff-add">+ <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">string</span> <span class="cshar-navy">word</span>, <span class="cshar-navy">int</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">PointerGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>* <span class="cshar-navy">matrix</span>, <span class="cshar-navy">char</span>* <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()</span>
  {
      <span class="csharp-navy">this</span>.word = word;
<span class="diff-remove">-     <span class="csharp-navy">this</span>.maxEdits = (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">this</span>.maxEdits = maxEdits;</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">int</span> <span class="cshar-navy">maxEdits</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> maxEdits;</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">builderLength</span> = word.Length + (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> builderLength = word.Length + (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>;</span>
  <span class="csharp-navy">var</span> builder = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[builderLength];
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; builderLength; i++)
  {
      builder[i] = <span class="csharp-brown">' '</span>;
  }

<span class="diff-add">+ builder++;</span>
<span class="diff-add">+</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">closure</span> = <span class="csharp-navy">new</span> ClosureVariable(word, maxEdits, _graph, matrix, builder, results);</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(word, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);</span>
  Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
  <span class="csharp-navy">return</span> results;
         }

<span class="diff-remove">-        <span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">int</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span></span>
<span class="diff-add">+        <span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
         {
<span class="diff-remove">- <span class="csharp-navy">if</span> (depth == closure.word.Length + closure.maxEdits)</span>
<span class="diff-add">+ <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth == closure.word.Length + (<span class="csharp-navy">int</span>)closure.maxEdits)</span>
  {
<span class="diff-remove">-     <span class="csharp-navy">return</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">goto</span> end;</span>
  }

<span class="diff-remove">- <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex;</span>
<span class="diff-remove">- <span class="csharp-navy">var</span> firstChild = fIndex[currentNode];</span>
<span class="diff-remove">- <span class="csharp-navy">var</span> lastChild = fIndex[currentNode + <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex + currentNode;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> firstChild = *fIndex;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> lastChild = *(fIndex + <span class="csharp-teal">1</span>);</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">to</span> = (<span class="csharp-navy">long</span>)Math.Min(closure.word.Length + <span class="csharp-teal">1</span>, depth + closure.maxEdits + <span class="csharp-teal">2</span>);</span>
  <span class="csharp-navy">var</span> previousCharacter = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;

<span class="diff-remove">- <span class="csharp-navy">var</span> rowLength = closure.word.Length + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.word.Length + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> to = Math.Min(rowLength, depth + closure.maxEdits + <span class="csharp-teal">2</span>);</span>
  <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
  <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;
  ++depth;

<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">any</span> = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[childEdge];
      closure.builder[depth - <span class="csharp-teal">1</span>] = currentCharacter;
<span class="diff-remove">-     <span class="csharp-navy">var</span> calculatedCost = depth;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> calculatedCost = (<span class="csharp-navy">int</span>)depth;</span>
      <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
      <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
      {
          <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
<span class="diff-remove">-         targetCharacter = closure.word[i - <span class="csharp-teal">1</span>];</span>
<span class="diff-add">+         targetCharacter = closure.word[(<span class="csharp-navy">int</span>)i - <span class="csharp-teal">1</span>];</span>

<span class="diff-break">@@</span>
      <span class="cshar-navy">if</span> (<span class="cshar-navy">nextNode</span> &lt; 0)
      {
          nextNode = -nextNode;
<span class="diff-remove">-         <span class="csharp-navy">if</span> (depth &gt;= closure.word.Length - closure.maxEdits</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth &gt;= closure.word.Length - (<span class="csharp-navy">int</span>)closure.maxEdits</span>
              &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
          {
<span class="diff-remove">-             closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, depth), <span class="csharp-teal">0</span>));</span>
<span class="diff-add">+             closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>)depth), <span class="csharp-teal">0</span>));</span>
          }
      }

      Recurse(nextNode, depth, <span class="csharp-navy">ref</span> closure);
  }
<span class="diff-add">+</span>
<span class="diff-add">+ end:;</span>
}
</code></pre>
    </details>
    <p>
      A big difference for such a small change.
    </p>
    <p>
      637.6 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 10</h3>
      <p>Reducing indirection</p>
    </header>
    <p>
      closure.word.Length requires the address of word to be retrieved from ClosureVariable, then the value of Length is retrieved from word.
      Storing that value directly in the struct removes a layer of indirection and gives us a small boost.
    </p>
    <details>
      <summary><h4>diff Dawg21.cs Dawg22.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
      <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">string</span> <span class="cshar-navy">word</span>, <span class="cshar-navy">int</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">PointerGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>* <span class="cshar-navy">matrix</span>, <span class="cshar-navy">char</span>* <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()
      {
          <span class="csharp-navy">this</span>.word = word;
<span class="diff-add">+         wordLength = word.Length;</span>
          <span class="csharp-navy">this</span>.maxEdits = maxEdits;

<span class="diff-break">@@</span>
      <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">string</span> <span class="cshar-navy">word</span>;
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> wordLength;</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> maxEdits;

<span class="diff-break">@@</span>
  <span class="cshar-navy">private</span> <span class="cshar-navy">static</span> <span class="cshar-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="cshar-navy">int</span> <span class="cshar-navy">currentNode</span>, <span class="cshar-navy">long</span> <span class="cshar-navy">depth</span>, <span class="cshar-navy">ref</span> <span class="cshar-navy">ClosureVariable</span> <span class="cshar-navy">closure</span>)
  {
<span class="diff-remove">-     <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth == closure.word.Length + (<span class="csharp-navy">int</span>)closure.maxEdits)</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth == closure.wordLength + (<span class="csharp-navy">int</span>)closure.maxEdits)</span>
      {
          <span class="csharp-navy">goto</span> end;
      }

<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">previousCharacter</span> = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;

<span class="diff-remove">-     <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.word.Length + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.wordLength + <span class="csharp-teal">1</span>;</span>
      <span class="csharp-navy">var</span> to = Math.Min(rowLength, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
      <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
      <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;

<span class="diff-break">@@</span>
           <span class="cshar-navy">if</span> (<span class="cshar-navy">targetCharacter</span> == previousCharacter
               &amp;&amp; previousTargetCharacter == currentCharacter)
           {
<span class="diff-remove">-              previousRowPreviousEntry = previousRow[i - closure.word.Length - <span class="csharp-teal">3</span>];</span>
<span class="diff-add">+              previousRowPreviousEntry = previousRow[i - closure.wordLength - <span class="csharp-teal">3</span>];</span>
           }

<span class="diff-break">@@</span>
          <span class="cshar-navy">if</span> (<span class="cshar-navy">nextNode</span> &lt; 0)
          {
              nextNode = -nextNode;
<span class="diff-remove">-             <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth &gt;= closure.word.Length - (<span class="csharp-navy">int</span>)closure.maxEdits</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth &gt;= closure.wordLength - (<span class="csharp-navy">int</span>)closure.maxEdits</span>
                  &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)
              {
</code></pre>
    </details>
    <p>
      Again, I don't know why this time is worse.
    </p>
    <p>
      658.2 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 11</h3>
      <p>Reducing indirection</p>
    </header>
    <p>
      previousCharacter is loaded outside of both loops and stored for later.
      The problem is that we have too many variables flying around and not enough registers.
      This causes previousCharacter to be stored on the stack.
      We don't always have transpositions in the Recurse method, so writing and loading to memory for something you might not access is not the best idea.
    </p>
    <p>
      Notice that the very similar address for closure.builder[depth - 1] (same LoC but depth has changed) is being indirectly computed at the start of the outer loop.
      If we use a variable to store that address, we can write directly to it as well as read (with an offset of -1) to grab previousCharacter on the fly.
      Even if this gets stored to the stack, the indirection is no worse that closure.builder.
      The previously eager load of previousCharacter (including a range check) now occurs much less often.
    </p>
    <details>
      <summary><h4>diff Dawg22.cs Dawg23.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">previousCharacter</span> = depth &gt; <span class="csharp-teal">0</span> ? closure.builder[depth - <span class="csharp-teal">1</span>] : (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;</span>
<span class="diff-remove">-</span>
  <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.wordLength + <span class="csharp-teal">1</span>;
  <span class="csharp-navy">var</span> to = Math.Min(rowLength, depth + closure.maxEdits + <span class="csharp-teal">2</span>);
  <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
  <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;
<span class="diff-add">+ <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;</span>
  ++depth;

  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)
  {
      <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
      <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[childEdge];
<span class="diff-remove">-     closure.builder[depth - <span class="csharp-teal">1</span>] = currentCharacter;</span>
<span class="diff-add">+     *builderPosition = currentCharacter;</span>
      <span class="csharp-navy">var</span> calculatedCost = (<span class="csharp-navy">int</span>)depth;
      <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
      <span class="csharp-navy">var</span> tar
      getCharacter = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;

<span class="diff-break">@@</span>
<span class="diff-remove">-             <span class="cshar-navy">if</span> (<span class="cshar-navy">targetCharacter</span> == previousCharacter</span>
<span class="diff-remove">-                 &amp;&amp; previousTargetCharacter == currentCharacter)</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (previousTargetCharacter == currentCharacter</span>
<span class="diff-add">+                 &amp;&amp; targetCharacter == *(builderPosition - <span class="csharp-teal">1</span>))</span>
              {
                  previousRowPreviousEntry = previousRow[i - closure.wordLength - <span class="csharp-teal">3</span>];
              }
</code></pre>
    </details>
    <p>
      591.2 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Branch reduction - part 2</h3>
    </header>
    <p>
      Using a for loop results in the compiler creating two bound checks: one before the first iteration and one at the end for continuing.
      A do-while loop will omit the first of these.
    </p>
    <p>
      In the case of our outer loop, we can't guarantee that the first iteration will fit the bounds, but we can move that check to an earlier part of the method.
      Doing so saves us from performing a lot of the setup that happens before the loops.
    </p>
    <details>
      <summary><h4>diff Dawg23.cs Dawg24.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">fIndex</span> = closure.FirstChildEdgeIndex + currentNode;
  <span class="csharp-navy">var</span> firstChild = *fIndex;
  <span class="csharp-navy">var</span> lastChild = *(fIndex + <span class="csharp-teal">1</span>);
<span class="diff-add">+ <span class="csharp-navy">if</span> (firstChild &gt;= lastChild)</span>
<span class="diff-add">+ {</span>
<span class="diff-add">+     <span class="csharp-navy">goto</span> end;</span>
<span class="diff-add">+ }</span>

  <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - closure.maxEdits;
  <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &lt; <span class="csharp-teal">0</span>)

<span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">builderPosition</span> = closure.builder + depth;
  ++depth;

<span class="diff-remove">- <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> childEdge = firstChild; childEdge &lt; lastChild; childEdge++)</span>
<span class="diff-add">+ <span class="csharp-navy">do</span></span>
  {
      <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;
<span class="diff-remove">-     <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[childEdge];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[firstChild];</span>
      *builderPosition = currentCharacter;
      <span class="csharp-navy">var</span> calculatedCost = (<span class="csharp-navy">int</span>) depth;

<span class="diff-break">@@</span>
          <span class="cshar-navy">continue</span>;
      }

<span class="diff-remove">-     <span class="csharp-navy">var</span> nextNode = closure.EdgeToNodeIndex[childEdge];</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> nextNode = closure.EdgeToNodeIndex[firstChild];</span>
      <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>)
      {
          nextNode = -nextNode;

<span class="diff-break">@@</span>
      }

      <span class="cshar-navy">Recurse</span>(<span class="cshar-navy">nextNode</span>, <span class="cshar-navy">depth</span>, <span class="cshar-navy">ref</span> <span class="cshar-navy">closure</span>);
<span class="diff-remove">- }</span>
<span class="diff-add">+ } <span class="csharp-navy">while</span> (++firstChild &lt; lastChild);</span>

  end:;
}
</code></pre>
    </details>
    <p>
      592.6 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Branch reduction - part 3</h3>
    </header>
    <p>
      Math.Min uses 2 jumps to accomplish what should only need 1.
      By replacing the call to it with a single check and assignment, we can save some jumps and mov instructions.
      In the case of our outer loop, we can't guarantee that the first iteration will fit the bounds, but we can move that check to an earlier part of the method.
      Doing so saves us from performing a lot of the setup that happens before the loops.
    </p>
    <p>
      We can also replace an existing branch with some arithmetic operators.
      Taking the Min of a number and 0 can be accomplished with a few steps.
      First we take the value and perform a shift-arithmetic-right.
      If the number is negative we obtain a series of 1s, otherwise a series of 0s.
      Then we flip that series using a complement operator.
      Finally, a logical AND will turn that series into a mask, 0-ing the value if it was negative or preserving it otherwise.
    </p>
    <p>
      any can be turned from a bool to an int and avoid the branch that sets it.
      Previously we couldn't do much in this area because the register pressure caused any to be saved on the stack.
      With the help of changes through our many iterations of Dawg, we now have a free register available.
      By shifting the matrix values down by 1 (below 0 is good, instead of 0 or lower before), we can use the calculatedCost as a mask.
      Any valid cost will have a 1 in the first bit, making it a negative value.
      By OR-ing calculatedCost every iteration, if any of them are valid our flag will be made negative as well.
    </p>
    <p>
      After shifting the matrix entries I noticed that the calculatedCost = (int) depth; assignment was unnecessary.
      This is a repeat of Dawg15's issue.
      Any entries before our stripe are invalid anyways so the value was never used.
      Initializing with 0 is a safe bet because it will always be invalid.
    </p>
    <p>
      Since we're on the topic of stripes...
      (int) depth >= closure.wordLength - (int) closure.maxEdits can be converted to (int) to > closure.wordLength
    </p>
    <p>
      Now that our register pressure is a little more under control, I noticed that a lot of the stack activity was around adding results.
      Just by moving some code around and un-nesting the method calls and constructors, I managed to improve performance a bit.
    </p>
    <details>
      <summary><h4>diff Dawg24.cs Dawg25.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">for</span> (<span class="cshar-navy">var</span> <span class="cshar-navy">i</span> = <span class="csharp-teal">0</span>; i &lt; rowCount; i++)
  {

<span class="diff-remove">-     matrix[i * rowLength] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     matrix[i * rowLength] = i - (<span class="csharp-navy">int</span>)maxEdits - <span class="csharp-teal">1</span>;</span>

      <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;
      <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
      {
<span class="diff-remove">-         matrix[i * rowLength + stripeEnd] = <span class="csharp-teal">0</span>;</span>
<span class="diff-add">+         matrix[i * rowLength + stripeEnd] = <span class="csharp-teal">-1</span>;</span>
      }
  }

  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowLength; i++)
  {
<span class="diff-remove">-     matrix[i] = i - (<span class="csharp-navy">int</span>)maxEdits;</span>
<span class="diff-add">+     matrix[i] = i - (<span class="csharp-navy">int</span>)maxEdits - <span class="csharp-teal">1</span>;</span>
  }

<span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">from</span> = depth - closure.maxEdits;
<span class="diff-remove">- <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &lt; <span class="csharp-teal">0</span>)</span>
<span class="diff-remove">- {</span>
<span class="diff-remove">-     <span class="csharp-navy">from</span> = <span class="csharp-teal">0</span>;</span>
<span class="diff-remove">- }</span>
<span class="diff-add">+ <span class="csharp-navy">from</span> &amp;= ~<span class="csharp-navy">from</span> &gt;&gt; <span class="csharp-teal">31</span>;</span>

  <span class="csharp-navy">from</span>++;

  <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.wordLength + <span class="csharp-teal">1</span>;
<span class="diff-remove">- <span class="csharp-navy">var</span> to = Math.Min(rowLength, depth + closure.maxEdits + <span class="csharp-teal">2</span>);</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> to = depth + closure.maxEdits + <span class="csharp-teal">2</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">if</span> (rowLength &lt; to)</span>
<span class="diff-add">+ {</span>
<span class="diff-add">+     to = rowLength;</span>
<span class="diff-add">+ }</span>
  <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
  <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;

<span class="diff-break">@@</span>
  <span class="cshar-navy">do</span>
  {
<span class="diff-remove">-     <span class="csharp-navy">var</span> any = <span class="csharp-blue">false</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> any = <span class="csharp-teal">0</span>;</span>
      <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[firstChild];
      *builderPosition = currentCharacter;
<span class="diff-remove">-     <span class="csharp-navy">var</span> calculatedCost = (<span class="csharp-navy">int</span>) depth;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> calculatedCost = <span class="csharp-teal">0</span>;</span>
      <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
      <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>) <span class="csharp-teal">0</span>;

<span class="diff-break">@@</span>
              <span class="cshar-navy">calculatedCost</span>++;
          }

<span class="diff-remove">-         <span class="csharp-navy">if</span> (calculatedCost &lt;= <span class="csharp-teal">0</span>)</span>
<span class="diff-remove">-         {</span>
<span class="diff-remove">-             any = <span class="csharp-blue">true</span>;</span>
<span class="diff-remove">-         }</span>
<span class="diff-add">+         any |= calculatedCost;</span>

          currentRow[i] = calculatedCost;
      }

<span class="diff-remove">-     <span class="csharp-navy">if</span> (!any)</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (any &gt;= <span class="csharp-teal">0</span>)</span>
      {
          <span class="csharp-navy">continue</span>;
      }

<span class="diff-break">@@</span>
      <span class="cshar-navy">if</span> (<span class="cshar-navy">nextNode</span> &lt; 0)
      {
          nextNode = -nextNode;
<span class="diff-remove">-         <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>) depth &gt;= closure.wordLength - (<span class="csharp-navy">int</span>) closure.maxEdits</span>
<span class="diff-remove">-             &amp;&amp; calculatedCost &lt;= <span class="csharp-teal">0</span>)</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>) to &gt; closure.wordLength</span>
<span class="diff-add">+             &amp;&amp; calculatedCost &lt; <span class="csharp-teal">0</span>)</span>
          {
<span class="diff-remove">-             closure.results.Add(<span class="csharp-navy">new</span> SuggestItem(<span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>) depth), <span class="csharp-teal">0</span>));</span>
<span class="diff-add">+             <span class="csharp-navy">var</span> str = <span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>) depth);</span>
<span class="diff-add">+             <span class="csharp-navy">var</span> si = <span class="csharp-navy">new</span> SuggestItem(str, <span class="csharp-teal">0</span>);</span>
<span class="diff-add">+             closure.results.Add(si);</span>
          }
      }
</code></pre>
    </details>
    <p>
      Quite a few changes in this one, but they were only effective together.
      The pay-off was great though.
    </p>
    <p>
      498.8 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 12</h3>
    </header>
    <p>
      It looks like we're still accessing the stack in our inner loop.
      To alleviate this we need to reduce the number of variables we use in said loop.
      previousRowPreviousEntry is a good candidate because one of the branches doesn't use it at all.
      The other branch can be re-ordered to use that value before over-writing it, requiring one less saved variable and thus register.
    </p>
    <p>
      The calculation for closure.word[i-1] was also taking up a temporary variable.
      By shifting closure.word by 1 during the preparation phase, we can remove the -1 and remove the need for that temporary register.
    </p>
    <details>
      <summary><h4>diff Dawg25.cs Dawg26.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">string</span> <span class="cshar-navy">word</span>, <span class="cshar-navy">int</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">PointerGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>* <span class="cshar-navy">matrix</span>, <span class="cshar-navy">char</span>* <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()</span>
<span class="diff-add">+ <span class="cshar-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="cshar-navy">char</span>* <span class="cshar-navy">word</span>, <span class="cshar-navy">int</span> <span class="cshar-navy">wordLength</span>, <span class="cshar-navy">int</span> <span class="cshar-navy">maxEdits</span>, <span class="cshar-navy">PointerGraph</span> <span class="cshar-navy">graph</span>, <span class="cshar-navy">int</span>* <span class="cshar-navy">matrix</span>, <span class="cshar-navy">char</span>* <span class="cshar-navy">builder</span>, <span class="cshar-navy">List</span>&lt;<span class="cshar-navy">SuggestItem</span>&gt; <span class="cshar-navy">results</span>) : <span class="cshar-navy">this</span>()</span>
  {
      <span class="csharp-navy">this</span>.word = word;
<span class="diff-remove">-     wordLength = word.Length;</span>
<span class="diff-add">+     <span class="csharp-navy">this</span>.wordLength = wordLength;</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">string</span> <span class="cshar-navy">word</span>;</span>
<span class="diff-add">+ <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* word;</span>

<span class="diff-break">@@</span>
<span class="diff-remove">- <span class="cshar-navy">var</span> <span class="cshar-navy">closure</span> = <span class="csharp-navy">new</span> ClosureVariable(word, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> wordCopy = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[word.Length];</span>
<span class="diff-add">+ <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; word.Length; i++)</span>
<span class="diff-add">+ {</span>
<span class="diff-add">+     wordCopy[i] = word[i];</span>
<span class="diff-add">+ }</span>
<span class="diff-add">+</span>
<span class="diff-add">+ <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(wordCopy - <span class="csharp-teal">1</span>, word.Length, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);</span>
  Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);
  <span class="csharp-navy">return</span> results;

<span class="diff-break">@@</span>
      <span class="cshar-navy">for</span> (<span class="cshar-navy">var</span> <span class="cshar-navy">i</span> = <span class="csharp-navy">from</span>; i &lt; to; i++)
      {
          <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
<span class="diff-remove">-         targetCharacter = closure.word[(<span class="csharp-navy">int</span>) i - <span class="csharp-teal">1</span>];</span>
<span class="diff-remove">-</span>
<span class="diff-remove">-         <span class="csharp-navy">var</span> previousRowPreviousEntry = previousRowEntry;</span>
<span class="diff-remove">-         previousRowEntry = previousRow[i];</span>
<span class="diff-remove">-</span>
<span class="diff-add">+         targetCharacter = closure.word[i];</span>
          <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
          {
<span class="diff-remove">-             calculatedCost = previousRowPreviousEntry;</span>
<span class="diff-add">+             calculatedCost = previousRowEntry;</span>
<span class="diff-add">+             previousRowEntry = previousRow[i];</span>
          }
          <span class="csharp-navy">else</span>
          {
<span class="diff-remove">-             <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)</span>
<span class="diff-remove">-             {</span>
<span class="diff-remove">-                 calculatedCost = previousRowEntry;</span>
<span class="diff-remove">-             }</span>

              <span class="csharp-navy">if</span> (previousTargetCharacter == currentCharacter
                  &amp;&amp; targetCharacter == *(builderPosition - <span class="csharp-teal">1</span>))
              {
<span class="diff-remove">-                 previousRowPreviousEntry = previousRow[i - closure.wordLength - <span class="csharp-teal">3</span>];</span>
<span class="diff-add">+                 previousRowEntry = previousRow[i - closure.wordLength - <span class="csharp-teal">3</span>];</span>
<span class="diff-add">+             }</span>
<span class="diff-add">+</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)</span>
<span class="diff-add">+             {</span>
<span class="diff-add">+                 calculatedCost = previousRowEntry;</span>
              }

<span class="diff-remove">-             <span class="csharp-navy">if</span> (previousRowPreviousEntry &lt; calculatedCost)</span>
<span class="diff-add">+             previousRowEntry = previousRow[i];</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)</span>
              {
<span class="diff-remove">-                 calculatedCost = previousRowPreviousEntry;</span>
<span class="diff-add">+                 calculatedCost = previousRowEntry;</span>
              }
</code></pre>
    </details>
    <p>
      Another regression that doesn't add up with the assembly changes.
      This step is necessary for the next ones to pay off though, so wait and see.
    </p>
    <p>
      510.6 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Algorithm refinement - part 5</h3>
    </header>
    <p>
      The best value an entry can possibly contain is equal to the value from the entry located in the previous row and previous column.
      This would represent a character match.
      If this entry is not valid, the current entry cannot possibly be valid itself.
      From this we introduce the concept of skipping.
    </p>
    <p>
      As an additional parameter in our recursion method we add int skip.
      This represents the number of steps to skip from the start of the stripe.
      Omitting these entries is less work to do and gains us a bit more performance.
    </p>
    <p>
      This finally gives us the opportunity to check "if ((int) depth &lt; (int)closure.wordLength + (int)closure.maxEdits)" before calling Recurse.
    </p>
    <p>
      The changes made here also allowed for a small gain by re-ordering operations at the start of the method.
    </p>
    <details>
      <summary><h4>diff Dawg26.cs Dawg27.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
      <span class="cshar-navy">public</span> <span class="cshar-navy">readonly</span> <span class="cshar-navy">char</span>* <span class="cshar-navy">word</span>;
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span> wordLength;</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> wordLength;</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> maxEdits;
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* matrix;

<span class="diff-break">@@</span>
  {
      <span class="csharp-navy">var</span> builderLength = word.Length + (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>;
      <span class="csharp-navy">var</span> builder = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[builderLength];
<span class="diff-add">+     <span class="csharp-green">// It makes no sense but leaving this here makes it faster.</span></span>
      <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; builderLength; i++)
      {
          builder[i] = <span class="csharp-brown">' '</span>;

<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">closure</span> = <span class="csharp-navy">new</span> ClosureVariable(wordCopy - <span class="csharp-teal">1</span>, word.Length, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);
<span class="diff-remove">-     Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+     Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);</span>
      <span class="csharp-navy">return</span> results;
  }

<span class="diff-remove">- <span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> depth, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
<span class="diff-add">+ <span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> depth, <span class="csharp-navy">long</span> skip, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span></span>
  {
<span class="diff-remove">-     <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)depth == closure.wordLength + (<span class="csharp-navy">int</span>)closure.maxEdits)</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> rowLength = closure.wordLength + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> to = depth + closure.maxEdits + <span class="csharp-teal">2</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (rowLength &lt; to)</span>
<span class="diff-add">+     {</span>
<span class="diff-add">+         to = rowLength;</span>
<span class="diff-add">+     }</span>
<span class="diff-add">+ </span>
<span class="diff-add">+     <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - closure.maxEdits;</span>
<span class="diff-add">+     <span class="csharp-navy">from</span> &amp;= ~<span class="csharp-navy">from</span> &gt;&gt; <span class="csharp-teal">63</span>;</span>
<span class="diff-add">+     <span class="csharp-navy">from</span> += skip + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+ </span>
<span class="diff-add">+     <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &gt;= to)</span>
      {
          <span class="csharp-navy">goto</span> end;
      }

<span class="diff-add">+     <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;</span>
<span class="diff-add">+     depth += <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+ </span>
      <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex + currentNode;
      <span class="csharp-navy">var</span> firstChild = *fIndex;

<span class="diff-break">@@</span>
          <span class="cshar-navy">goto</span> <span class="cshar-navy">end</span>;
      }

<span class="diff-remove">-     <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - closure.maxEdits;</span>
<span class="diff-remove">-     <span class="csharp-navy">from</span> &amp;= ~<span class="csharp-navy">from</span> &gt;&gt; <span class="csharp-teal">31</span>;</span>
<span class="diff-remove">-</span>
<span class="diff-remove">-     <span class="csharp-navy">from</span>++;</span>
<span class="diff-remove">-</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> rowLength = (<span class="csharp-navy">long</span>)closure.wordLength + <span class="csharp-teal">1</span>;</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> to = depth + closure.maxEdits + <span class="csharp-teal">2</span>;</span>
<span class="diff-remove">-     <span class="csharp-navy">if</span> (rowLength &lt; to)</span>
<span class="diff-remove">-     {</span>
<span class="diff-remove">-         to = rowLength;</span>
<span class="diff-remove">-     }</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;</span>
<span class="diff-remove">-     <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;</span>
<span class="diff-remove">-     ++depth;</span>
<span class="diff-remove">-</span>
      <span class="csharp-navy">do</span>
      {
<span class="diff-remove">-         <span class="csharp-navy">var</span> any = <span class="csharp-teal">0</span>;</span>
          <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[firstChild];
          *builderPosition = currentCharacter;
<span class="diff-remove">-         <span class="csharp-navy">var</span> calculatedCost = <span class="csharp-teal">0</span>;</span>
          <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
<span class="diff-add">+         <span class="csharp-navy">var</span> any = <span class="csharp-teal">0</span>;</span>
<span class="diff-add">+         <span class="csharp-navy">var</span> calculatedCost = <span class="csharp-teal">0</span>;</span>
          <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>) <span class="csharp-teal">0</span>;
          <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)

<span class="diff-break">@@</span>
          <span class="cshar-navy">if</span> (<span class="cshar-navy">nextNode</span> &lt; 0)
          {
              nextNode = -nextNode;
<span class="diff-remove">-             <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>) to &gt; closure.wordLength</span>
<span class="diff-remove">-                 &amp;&amp; calculatedCost &lt; <span class="csharp-teal">0</span>)</span>
<span class="diff-add">+             <span class="csharp-navy">if</span> (calculatedCost &lt; <span class="csharp-teal">0</span></span>
<span class="diff-add">+                 &amp;&amp; (<span class="csharp-navy">int</span>) to &gt; (<span class="csharp-navy">int</span>)closure.wordLength)</span>
              {
                  <span class="csharp-navy">var</span> str = <span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>) depth);

<span class="diff-break">@@</span>
              }
          }

<span class="diff-remove">-         <span class="cshar-navy">Recurse</span>(<span class="cshar-navy">nextNode</span>, <span class="cshar-navy">depth</span>, <span class="cshar-navy">ref</span> <span class="cshar-navy">closure</span>);</span>
<span class="diff-add">+         <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>) depth &lt; (<span class="csharp-navy">int</span>)closure.wordLength + (<span class="csharp-navy">int</span>)closure.maxEdits)</span>
<span class="diff-add">+         {</span>
<span class="diff-add">+             <span class="csharp-navy">var</span> newSkip = skip;</span>
<span class="diff-add">+             <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>;; i++)</span>
<span class="diff-add">+             {</span>
<span class="diff-add">+                 <span class="csharp-navy">if</span> (currentRow[i] &gt;= <span class="csharp-teal">0</span>)</span>
<span class="diff-add">+                 {</span>
<span class="diff-add">+                     newSkip++;</span>
<span class="diff-add">+                 }</span>
<span class="diff-add">+                 <span class="csharp-navy">else</span></span>
<span class="diff-add">+                 {</span>
<span class="diff-add">+                     <span class="csharp-navy">break</span>;</span>
<span class="diff-add">+                 }</span>
<span class="diff-add">+             }</span>
<span class="diff-add">+</span>
<span class="diff-add">+             Recurse(nextNode, depth, newSkip, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+         }</span>
      } <span class="csharp-navy">while</span> (++firstChild &lt; lastChild);

      end:;
</code></pre>
    </details>
    <p>
      452.6 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 13</h3>
    </header>
    <p>
      Similarly to how we used "(int)to > (int)closure.wordLength" in Dawg25 to avoid loading closure.maxEdits and subtracting it, we can use "from" in our recursion bound check.
    </p>
    <p>
      I also tried adding a bound check before performing the work of calculating newSkip, but found it didn't help.
    </p>
    <details>
      <summary><h4>diff Dawg27.cs Dawg28.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
  <span class="cshar-navy">var</span> <span class="cshar-navy">builderLength</span> = word.Length + (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>;
  <span class="csharp-navy">var</span> builder = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[builderLength];
<span class="diff-remove">- <span class="csharp-green">// It makes no sense but leaving this here makes it faster.</span></span>
  <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; builderLength; i++)
  {
<span class="diff-remove">-     builder[i] = <span class="csharp-brown">' '</span>;</span>
<span class="diff-add">+     builder[i] = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;</span>
  }

  builder++;

<span class="diff-break">@@</span>
   <span class="cshar-navy">var</span> <span class="cshar-navy">rowLength</span> = word.Length + <span class="csharp-teal">1</span>;
   <span class="csharp-navy">var</span> rowCount = rowLength + (<span class="csharp-navy">int</span>)maxEdits;
   <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">int</span>[rowLength * rowCount];
<span class="diff-add">+  <span class="csharp-navy">var</span> mp1 = (<span class="csharp-navy">int</span>) maxEdits + <span class="csharp-teal">1</span>;</span>
   <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowCount; i++)
   {

<span class="diff-remove">-      matrix[i * rowLength] = i - (<span class="csharp-navy">int</span>)maxEdits - <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+      matrix[i * rowLength] = i - mp1;</span>

<span class="diff-remove">-      <span class="csharp-navy">var</span> stripeEnd = i + maxEdits + <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+      <span class="csharp-navy">var</span> stripeEnd = i + mp1;</span>
       <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
       {
           matrix[i * rowLength + stripeEnd] = <span class="csharp-teal">-1</span>;

<span class="diff-break">@@</span>
       <span class="cshar-navy">goto</span> <span class="cshar-navy">end</span>;
   }

<span class="diff-remove">-  <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;</span>
   <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
   <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;
<span class="diff-add">+  <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;</span>
   depth += <span class="csharp-teal">1</span>;

   <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex + currentNode;

<span class="diff-break">@@</span>
<span class="diff-remove">-      <span class="cshar-navy">if</span> ((<span class="cshar-navy">int</span>) <span class="cshar-navy">depth</span> &lt; (<span class="cshar-navy">int</span>)<span class="cshar-navy">closure.wordLength</span> + (<span class="cshar-navy">int</span>)<span class="cshar-navy">closure.maxEdits</span>)</span>
<span class="diff-add">+      <span class="cshar-navy">if</span> ((<span class="cshar-navy">int</span>)<span class="cshar-navy">from</span> &lt; (<span class="cshar-navy">int</span>)<span class="cshar-navy">closure.wordLength</span>)</span>
       { 
           <span class="csharp-navy">var</span> newSkip = skip;
<span class="diff-add">+          <span class="csharp-green">//if (from &gt; 1)</span></span>
<span class="diff-add">+          {</span>
               <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>;; i++)
               {

<span class="diff-break">@@</span>
                       <span class="cshar-navy">break</span>;
                   }
               }
<span class="diff-add">+          }</span>

           Recurse(nextNode, depth, newSkip, <span class="csharp-navy">ref</span> closure);
       }
</code></pre>
    </details>
    <p>
      445.9 ms
    </p>
  </section></li>
  
  <li><section>
    <header>
      <h3>Memory access reduction - part 14</h3>
    </header>
    <p>
      The function argument skip is only used in calculating "from" and "newSkip".
      In both cases "from" is added before the resulting value is used.
      Instead of passing "skip" and calculating "from", we pass "from" directly.
    </p>
    <p>
      The Max(0, from) operation becomes from += depth > closure.maxEdits ? 1 : 0; which is replaced with some fun arithmetic operations.
    </p>
    <p>
      The compiler wasn't making great decisions when it came to which variable to store on the stack.
      "depth" isn't accessed in the inner loop, and is only rarely access in the outer loop.
      I couldn't exactly control storing it on the stack, so instead I moved it to ClosureVariable and made the struct editable.
    </p>
    <p>
      Now that depth is stored in closure, all the information necessary for adding a result are in one place.
      I extracted it to another method with ClosureVariable as a parameter.
      This removed the final stack storage and makes our function much cleaner.
      I also marked the new function as NoInlining, to prevent it from sneaking back in and causing trouble.
    </p>
    <p>
      One final thing that you might notice is I've moved "depth" to the start of the ClosureVariable.
      If it has an offset from "rsi" there's one additional instruction in assembly
    </p>
    <p>
      Storing depth on the stack if I could control it might actually be preferrable.
      The fact that it is used at all levels of recursion means we need to decrement it when leaving the method.
      That's an expensive load-modify-store operation and it could be entirely avoided if each method invocation used its own stack to store it.
      But then again, there's no guarantee that it would help, benchmarking is always needed.
    </p>
    <details>
      <summary><h4>diff Dawg28.cs Dawg29.cs</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"
><code class="language-csharp"><span class="diff-break">@@</span>
<span class="csharp-navy">using</span> System;
  <span class="csharp-navy">using</span> System.Collections.Generic;
  <span class="csharp-navy">using</span> System.Diagnostics;
  <span class="csharp-navy">using</span> System.IO;
<span class="diff-add">+ <span class="csharp-navy">using</span> System.Runtime.CompilerServices;</span>
<span class="diff-add">+ <span class="csharp-navy">using</span> System.Runtime.InteropServices;</span>
  <span class="csharp-navy">using</span> System.Text;

<span class="diff-break">@@</span>
  <span class="cshar-navy">public</span> <span class="cshar-navy">uint</span> <span class="cshar-navy">WordCount</span> { <span class="csharp-navy">get</span>; }

<span class="diff-remove">- <span class="csharp-navy">private</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">struct</span> ClosureVariable</span>
<span class="diff-add">+ [StructLayout(LayoutKind.Explicit)]</span>
<span class="diff-add">+ <span class="csharp-navy">private</span> <span class="csharp-navy">struct</span> ClosureVariable</span>
  {
      <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">char</span>* word, <span class="csharp-navy">int</span> wordLength, <span class="csharp-navy">int</span> maxEdits, PointerGraph graph, <span class="csharp-navy">int</span>* matrix, <span class="csharp-navy">char</span>* builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)

<span class="diff-break">@@</span>
          EdgeCharacters</span> = graph.EdgeCharacters;
          FirstChildEdgeIndex = graph.FirstChildEdgeIndex;
          EdgeToNodeIndex = graph.EdgeToNodeIndex;
<span class="diff-add">+</span>
<span class="diff-add">+         depth = <span class="csharp-teal">0</span>;</span>
      }

<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* word;</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x00</span>)]</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">long</span> depth;</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x08</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> wordLength;
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x10</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> maxEdits;
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x18</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* matrix;
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* builder;</span>
<span class="diff-remove">-     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;</span>
<span class="diff-remove">-</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x20</span>)]</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* word;</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x28</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* EdgeCharacters;
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x30</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint* FirstChildEdgeIndex;
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x38</span>)]</span>
      <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* EdgeToNodeIndex;
<span class="diff-add">+</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x40</span>)]</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* builder;</span>
<span class="diff-add">+     [FieldOffset(<span class="csharp-teal">0x48</span>)]</span>
<span class="diff-add">+     <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;</span>

<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">closure</span> = <span class="csharp-navy">new</span> ClosureVariable(wordCopy - <span class="csharp-teal">1</span>, word.Length, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);
<span class="diff-remove">-     Recurse(_graph.RootNodeIndex, <span class="csharp-teal">0</span>, <span class="csharp-teal">0</span>, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+     Recurse(_graph.RootNodeIndex, <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);</span>
      <span class="csharp-navy">return</span> results;
  }

<span class="diff-remove">- <span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> depth, <span class="csharp-navy">long</span> skip, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
<span class="diff-add">+ <span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> <span class="csharp-navy">from</span>, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span></span>
  {
<span class="diff-add">+     <span class="csharp-navy">var</span> depth = closure.depth;</span>
      <span class="csharp-navy">var</span> rowLength = closure.wordLength + <span class="csharp-teal">1</span>;
<span class="diff-add">+     <span class="csharp-navy">from</span> -= (closure.maxEdits - depth) &gt;&gt; <span class="csharp-teal">63</span>;</span>
      <span class="csharp-navy">var</span> to = depth + closure.maxEdits + <span class="csharp-teal">2</span>;
      <span class="csharp-navy">if</span> (rowLength &lt; to)
      {
          to = rowLength;
      }

<span class="diff-remove">-     <span class="csharp-navy">var</span> <span class="csharp-navy">from</span> = depth - closure.maxEdits;</span>
<span class="diff-remove">-     <span class="csharp-navy">from</span> &amp;= ~<span class="csharp-navy">from</span> &gt;&gt; <span class="csharp-teal">63</span>;</span>
<span class="diff-remove">-     <span class="csharp-navy">from</span> += skip + <span class="csharp-teal">1</span>;</span>
<span class="diff-remove">-</span>
      <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &gt;= to)
      {

<span class="diff-break">@@</span>
      <span class="cshar-navy">var</span> <span class="cshar-navy">currentRow</span> = previousRow + rowLength;
      <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;
<span class="diff-remove">-     depth += <span class="csharp-teal">1</span>;</span>
<span class="diff-add">+     closure.depth = depth + <span class="csharp-teal">1</span>;</span>

      <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex + currentNode;
      <span class="csharp-navy">var</span> firstChild = *fIndex;
      <span class="csharp-navy">var</span> lastChild = *(fIndex + <span class="csharp-teal">1</span>);
      <span class="csharp-navy">if</span> (firstChild &gt;= lastChild)
      {
<span class="diff-remove">-         <span class="csharp-navy">goto</span> end;</span>
<span class="diff-add">+         <span class="csharp-navy">goto</span> end2;</span>
      }

      <span class="csharp-navy">do</span>

<span class="diff-break">@@</span>
          <span class="cshar-navy">var</span> <span class="cshar-navy">nextNode</span> = closure.EdgeToNodeIndex[firstChild];
          <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>)
          {
<span class="diff-remove">-             nextNode = -nextNode;</span>
              <span class="csharp-navy">if</span> (calculatedCost &lt; <span class="csharp-teal">0</span>
                  &amp;&amp; (<span class="csharp-navy">int</span>)to &gt; (<span class="csharp-navy">int</span>)closure.wordLength)
              {
<span class="diff-remove">-                 <span class="csharp-navy">var</span> str = <span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>)depth);</span>
<span class="diff-remove">-                 <span class="csharp-navy">var</span> si = <span class="csharp-navy">new</span> SuggestItem(str, <span class="csharp-teal">0</span>);</span>
<span class="diff-remove">-                 closure.results.Add(si);</span>
<span class="diff-add">+                 Add(<span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+                 nextNode = closure.EdgeToNodeIndex[firstChild];</span>
              }
<span class="diff-add">+             nextNode = -nextNode;</span>
          }

          <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)<span class="csharp-navy">from</span> &lt; (<span class="csharp-navy">int</span>)closure.wordLength)
          { 
<span class="diff-remove">-             <span class="csharp-navy">var</span> newSkip = skip;</span>
<span class="diff-remove">-             <span class="csharp-green">//if (from &gt; 1)</span></span>
<span class="diff-remove">-             {</span>
<span class="diff-remove">-                 <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>;; i++)</span>
<span class="diff-add">+             <span class="csharp-navy">var</span> newFrom = <span class="csharp-navy">from</span>;</span>
<span class="diff-add">+             <span class="csharp-navy">while</span> (currentRow[newFrom] &gt;= <span class="csharp-teal">0</span>)</span>
              {
<span class="diff-remove">-                     <span class="csharp-navy">if</span> (currentRow[i] &gt;= <span class="csharp-teal">0</span>)</span>
<span class="diff-remove">-                     {</span>
<span class="diff-remove">-                         newSkip++;</span>
<span class="diff-remove">-                     }</span>
<span class="diff-remove">-                     <span class="csharp-navy">else</span></span>
<span class="diff-remove">-                     {</span>
<span class="diff-remove">-                         <span class="csharp-navy">break</span>;</span>
<span class="diff-remove">-                     }</span>
<span class="diff-remove">-                 }</span>
<span class="diff-add">+                 newFrom += <span class="csharp-teal">1</span>;</span>
              }

<span class="diff-remove">-             Recurse(nextNode, depth, newSkip, <span class="csharp-navy">ref</span> closure);</span>
<span class="diff-add">+             Recurse(nextNode, newFrom, <span class="csharp-navy">ref</span> closure);</span>
          }
      } <span class="csharp-navy">while</span> (++firstChild &lt; lastChild);

<span class="diff-add">+     end2:</span>
<span class="diff-add">+     closure.depth -= <span class="csharp-teal">1</span>;</span>
      end: ;
  }

<span class="diff-add">+ [MethodImpl(MethodImplOptions.NoInlining)]</span>
<span class="diff-add">+ <span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Add</span>(<span class="hljs-params"><span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
<span class="diff-add">+</span> {</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> str = <span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>)closure.depth);</span>
<span class="diff-add">+     <span class="csharp-navy">var</span> si = <span class="csharp-navy">new</span> SuggestItem(str, <span class="csharp-teal">0</span>);</span>
<span class="diff-add">+     closure.results.Add(si);</span>
<span class="diff-add">+ }</span>
<span class="diff-add">+</span>
</code></pre>
    </details>
    <p>
      435.1 ms
    </p>
  </section></li>
</ol>  
  <section>
    <header>
      <h3>Review of final version</h3>
    </header>
    <p>
      
    </p>
    <details>
      <summary><h4>Dawg.cs v3</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"><code class="language-csharp"
>[<span class="csharp-teal">StructLayout(LayoutKind.Explicit)</span>]
<span class="csharp-navy">private</span> <span class="csharp-navy">struct</span> ClosureVariable
{
    <span class="hljs-function"><span class="csharp-navy">public</span> <span class="cshar-navy">ClosureVariable</span>(<span class="hljs-params"><span class="csharp-navy">char</span>* word, <span class="csharp-navy">int</span> wordLength, <span class="csharp-navy">int</span> maxEdits, CompressedSparseRowGraph graph, <span class="csharp-navy">int</span>* matrix, <span class="csharp-navy">char</span>* builder, List&lt;SuggestItem&gt; results</span>) : <span class="cshar-navy">this</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="csharp-navy">this</span>.word = word;
        <span class="csharp-navy">this</span>.wordLength = wordLength;
        <span class="csharp-navy">this</span>.maxEdits = maxEdits;
        <span class="csharp-navy">this</span>.matrix = matrix;
        <span class="csharp-navy">this</span>.builder = builder;
        <span class="csharp-navy">this</span>.results = results;

        EdgeCharacters = graph.EdgeCharacters;
        FirstChildEdgeIndex = graph.FirstChildEdgeIndex;
        EdgeToNodeIndex = graph.EdgeToNodeIndex;

        depth = <span class="csharp-teal">0</span>;
    }

    [<span class="csharp-teal">FieldOffset(0x00)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">long</span> depth;
    [<span class="csharp-teal">FieldOffset(0x08)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> wordLength;
    [<span class="csharp-teal">FieldOffset(0x10)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">long</span> maxEdits;
    [<span class="csharp-teal">FieldOffset(0x18)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* matrix;
    [<span class="csharp-teal">FieldOffset(0x20)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* word;
    [<span class="csharp-teal">FieldOffset(0x28)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* EdgeCharacters;
    [<span class="csharp-teal">FieldOffset(0x30)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> uint* FirstChildEdgeIndex;
    [<span class="csharp-teal">FieldOffset(0x38)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">int</span>* EdgeToNodeIndex;

    [<span class="csharp-teal">FieldOffset(0x40)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> <span class="csharp-navy">char</span>* builder;
    [<span class="csharp-teal">FieldOffset(0x48)</span>]
    <span class="csharp-navy">public</span> <span class="csharp-navy">readonly</span> List&lt;SuggestItem&gt; results;
}

<span class="hljs-function"><span class="csharp-navy">public</span> IEnumerable&lt;SuggestItem&gt; <span class="cshar-navy">Lookup</span>(<span class="hljs-params"><span class="csharp-navy">string</span> word, uint maxEdits</span>)</span>
{
    <span class="csharp-navy">var</span> builderLength = word.Length + (<span class="csharp-navy">int</span>)maxEdits + <span class="csharp-teal">1</span>;
    <span class="csharp-navy">var</span> builder = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[builderLength];
    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; builderLength; i++)
    {
        builder[i] = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;
    }

    builder++;

    <span class="csharp-navy">var</span> results = <span class="csharp-navy">new</span> List&lt;SuggestItem&gt;();

    <span class="csharp-navy">var</span> rowLength = word.Length + <span class="csharp-teal">1</span>;
    <span class="csharp-navy">var</span> rowCount = rowLength + (<span class="csharp-navy">int</span>)maxEdits;
    <span class="csharp-navy">var</span> matrix = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">int</span>[rowLength * rowCount];
    <span class="csharp-navy">var</span> mp1 = (<span class="csharp-navy">int</span>) maxEdits + <span class="csharp-teal">1</span>;
    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowCount; i++)
    {

        matrix[i * rowLength] = i - mp1;

        <span class="csharp-navy">var</span> stripeEnd = i + mp1;
        <span class="csharp-navy">if</span> (stripeEnd &lt;= word.Length)
        {
            matrix[i * rowLength + stripeEnd] = <span class="csharp-teal">-1</span>;
        }
    }

    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; rowLength; i++)
    {
        matrix[i] = i - (<span class="csharp-navy">int</span>)maxEdits - <span class="csharp-teal">1</span>;
    }

    <span class="csharp-navy">var</span> wordCopy = <span class="csharp-navy">stackalloc</span> <span class="csharp-navy">char</span>[word.Length];
    <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-teal">0</span>; i &lt; word.Length; i++)
    {
        wordCopy[i] = word[i];
    }

    <span class="csharp-navy">var</span> closure = <span class="csharp-navy">new</span> ClosureVariable(wordCopy - <span class="csharp-teal">1</span>, word.Length, (<span class="csharp-navy">int</span>)maxEdits, _graph, matrix, builder, results);
    Recurse(_graph.RootNodeIndex, <span class="csharp-teal">1</span>, <span class="csharp-navy">ref</span> closure);
    <span class="csharp-navy">return</span> results;
}

<span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Recurse</span>(<span class="hljs-params"><span class="csharp-navy">int</span> currentNode, <span class="csharp-navy">long</span> <span class="csharp-navy">from</span>, <span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
{
    <span class="csharp-navy">var</span> depth = closure.depth;
    <span class="csharp-navy">var</span> rowLength = closure.wordLength + <span class="csharp-teal">1</span>;
    <span class="csharp-navy">from</span> -= (closure.maxEdits - depth) &gt;&gt; <span class="csharp-teal">63</span>;
    <span class="csharp-navy">var</span> to = depth + closure.maxEdits + <span class="csharp-teal">2</span>;
    <span class="csharp-navy">if</span> (rowLength &lt; to)
    {
        to = rowLength;
    }

    <span class="csharp-navy">if</span> (<span class="csharp-navy">from</span> &gt;= to)
    {
        <span class="csharp-navy">goto</span> end;
    }

    <span class="csharp-navy">var</span> previousRow = closure.matrix + depth * rowLength;
    <span class="csharp-navy">var</span> currentRow = previousRow + rowLength;
    <span class="csharp-navy">var</span> builderPosition = closure.builder + depth;
    closure.depth = depth + <span class="csharp-teal">1</span>;

    <span class="csharp-navy">var</span> fIndex = closure.FirstChildEdgeIndex + currentNode;
    <span class="csharp-navy">var</span> firstChild = *fIndex;
    <span class="csharp-navy">var</span> lastChild = *(fIndex + <span class="csharp-teal">1</span>);
    <span class="csharp-navy">if</span> (firstChild &gt;= lastChild)
    {
        <span class="csharp-navy">goto</span> end2;
    }

    <span class="csharp-navy">do</span>
    {
        <span class="csharp-navy">var</span> currentCharacter = closure.EdgeCharacters[firstChild];
        *builderPosition = currentCharacter;
        <span class="csharp-navy">var</span> previousRowEntry = previousRow[<span class="csharp-navy">from</span> - <span class="csharp-teal">1</span>];
        <span class="csharp-navy">var</span> any = <span class="csharp-teal">0</span>;
        <span class="csharp-navy">var</span> calculatedCost = <span class="csharp-teal">0</span>;
        <span class="csharp-navy">var</span> targetCharacter = (<span class="csharp-navy">char</span>)<span class="csharp-teal">0</span>;
        <span class="csharp-navy">for</span> (<span class="csharp-navy">var</span> i = <span class="csharp-navy">from</span>; i &lt; to; i++)
        {
            <span class="csharp-navy">var</span> previousTargetCharacter = targetCharacter;
            targetCharacter = closure.word[i];
            <span class="csharp-navy">if</span> (currentCharacter == targetCharacter)
            {
                calculatedCost = previousRowEntry;
                previousRowEntry = previousRow[i];
            }
            <span class="csharp-navy">else</span>
            {
                <span class="csharp-navy">if</span> (previousTargetCharacter == currentCharacter
                    &amp;&amp; targetCharacter == *(builderPosition - <span class="csharp-teal">1</span>))
                {
                    previousRowEntry = previousRow[i - closure.wordLength - <span class="csharp-teal">3</span>];
                }

                <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)
                {
                    calculatedCost = previousRowEntry;
                }

                previousRowEntry = previousRow[i];
                <span class="csharp-navy">if</span> (previousRowEntry &lt; calculatedCost)
                {
                    calculatedCost = previousRowEntry;
                }

                calculatedCost++;
            }

            any |= calculatedCost;

            currentRow[i] = calculatedCost;
        }

        <span class="csharp-navy">if</span> (any &gt;= <span class="csharp-teal">0</span>)
        {
            <span class="csharp-navy">continue</span>;
        }

        <span class="csharp-navy">var</span> nextNode = closure.EdgeToNodeIndex[firstChild];
        <span class="csharp-navy">if</span> (nextNode &lt; <span class="csharp-teal">0</span>)
        {
            <span class="csharp-navy">if</span> (calculatedCost &lt; <span class="csharp-teal">0</span>
                &amp;&amp; (<span class="csharp-navy">int</span>)to &gt; (<span class="csharp-navy">int</span>)closure.wordLength)
            {
                Add(<span class="csharp-navy">ref</span> closure);
                nextNode = closure.EdgeToNodeIndex[firstChild];
            }
            nextNode = -nextNode;
        }

        <span class="csharp-navy">if</span> ((<span class="csharp-navy">int</span>)<span class="csharp-navy">from</span> &lt; (<span class="csharp-navy">int</span>)closure.wordLength)
        { 
            <span class="csharp-navy">var</span> newFrom = <span class="csharp-navy">from</span>;
            <span class="csharp-navy">while</span> (currentRow[newFrom] &gt;= <span class="csharp-teal">0</span>)
            {
                newFrom += <span class="csharp-teal">1</span>;
            }

            Recurse(nextNode, newFrom, <span class="csharp-navy">ref</span> closure);
        }
    } <span class="csharp-navy">while</span> (++firstChild &lt; lastChild);

    end2:
    closure.depth -= <span class="csharp-teal">1</span>;
    end: ;
}

[<span class="csharp-teal">MethodImpl(MethodImplOptions.NoInlining)</span>]
<span class="hljs-function"><span class="csharp-navy">private</span> <span class="csharp-navy">static</span> <span class="csharp-navy">void</span> <span class="cshar-navy">Add</span>(<span class="hljs-params"><span class="csharp-navy">ref</span> ClosureVariable closure</span>)</span>
{
    <span class="csharp-navy">var</span> str = <span class="csharp-navy">new</span> <span class="csharp-navy">string</span>(closure.builder, <span class="csharp-teal">0</span>, (<span class="csharp-navy">int</span>)closure.depth);
    <span class="csharp-navy">var</span> si = <span class="csharp-navy">new</span> SuggestItem(str, <span class="csharp-teal">0</span>);
    closure.results.Add(si);
}
</code></pre>
    </details>
    <p>
      
    </p>
  </section>

  <section>
    <header>
      <h3>Something I wish had worked</h3>
    </header>
    <p>
      One really clean change that can be made to the final version is to pass "currentRow" as an argument.
      If we use it as the previousRow for the next level, we can just add rowLength to get the new currentRow.
      The first call simply uses the pointer to matrix, removing the need to store it in ClosureVariable.
    </p>
    <p>
      So we've removed a memory read for closure.matrix and removed a multiplication for calculating previousRow.
      Unfortunately testing revealed it was not an improvement and regressed performance by quite a bit.
      Setting up the call stack must be more expensive than those operations.
    </p>
  </section>
  
  <section>
    <header>
      <h3>Another cool use of arithmetic</h3>
    </header>
    <p>
      We already iterate through currentRow in the inner loop, it would be nice if we could calculate newFrom there instead of iterating a second time.
      Thankfully, there is a way.
      Sadly, it is slower.
    </p>
    <p>
      We start with our newSkip variable being declared before the innerLoop and initialized to 0.
      Then during every iteration of the inner loop, we check "any" and update newSkip.
    </p>
    <p>
      If any is negative, we can add 1 to newSkip.
      We want 1 when the value is bad, 0 otherwise.
      Performing a shift-arithmetic-right to any, which will yield -1 when the value is good and 0 otherwise.
      Using the complement operator turns that 0 into -1 and vice versa.
      Finally, negating the result gets us our desired value which we can add to newSkip (or just subtract without negating).      
    </p>
    <p>
      In retrospect it's easy to see why this would be a step backways for performance.
      Most of the calls to Recurse have a low depth and therefore can't even provide a value for skip.
      The dependency chain for all the arithmetic is also quite long.
      Compare this to the second iteration quitting after the first load from currentRow and we quickly lose any potential gains.
    </p>
    <details>
      <summary><h4>Inner loop skip calculation</h4></summary>
<pre style="background: white; font-family: Consolas; font-size: 13px;"><code class="language-csharp"
><span class="csharp-navy">var</span> anyGoodEntries = any &gt;&gt; <span class="csharp-teal">31</span>; <span class="csharp-green">// 1s when true, 0s otherwise</span>
<span class="csharp-navy">var</span> continuousBadEntries = ~anyGoodEntries; <span class="csharp-green">// 1s == -1 when true; 0s == 0 otherwise</span>
skip2 -= continuousBadEntries; <span class="csharp-green">// Adds 1 if the entry can be skipped when calculating the next row.</span>
</code></pre>
    </details>
  </section>
  
  
</article>
</main>

<aside>
  <figure>
    <img src="https://jbp.dev/img/bird-small.jpg" alt="You caught me, I'm not a bird."/>
    <figcaption>Jean-Bernard Pellerin</figcaption>
  </figure>
  <p>
    Contact:
    I can be reached <a href="mailto:jbp@jbp.dev">by email</a>.
  </p>
</aside>

<footer>
  <p>
    <b><a href="https://jbp.dev/licenses.html">© 2019 Jean-Bernard Pellerin</a></b>
  </p>
</footer>  

</body>
</html>
