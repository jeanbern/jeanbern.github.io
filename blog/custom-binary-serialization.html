<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311168-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143311168-1');
  </script>
  <title>Custom Binary Serialization in C#</title>
  <meta name="author" content="Jean-Bernard Pellerin"/>
  <meta name="description" content="A method for serializing unmanaged C# types into a binary format. Very fast and allocates as little memory as possible."/>
  <meta name="generator" content="100% organic human"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="https://jbp.dev/blog/custom-binary-serialization.html"/>
  <link rel="license" href="https://jbp.dev/licenses.html"/>
  <link rel="stylesheet" href="https://jbp.dev/css/normalize.css"/>
  <link rel="stylesheet" href="https://jbp.dev/css/jeanbern.css"/>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
        {
            "@type": "Organization",
            "@id": "https://jbp.dev/#organization",
            "name": "jbp.dev",
            "url": "https://jbp.dev/",
            "sameAs": [
                "https://www.facebook.com/jbpellerin",
                "https://www.linkedin.com/in/jean-bernard-pellerin-026bbb23",
                "https://twitter.com/jeanbpellerin"
            ],
            "logo": {
                "@type": "ImageObject",
                "@id": "https://jbp.dev/#logo",
                "url": "https://jbp.dev/img/bird.jpg",
                "caption": "jbp.dev"
            },
            "image": {
                "@id": "https://jbp.dev/#logo"
            }
        },
        {
            "@type": "WebSite",
            "@id": "https://jbp.dev/#website",
            "url": "https://jbp.dev/",
            "name": "jbp.dev",
            "publisher": {
                "@id": "https://jbp.dev/#organization"
            }/*,
            "potentialAction": {
                "@type": "SearchAction",
                "target": "https://jbp.dev/?s={search_term_string}",
                "query-input": "required name=search_term_string"
            }*/
        },
        {
            "@type": "WebPage",
            "@id": "https://jbp.dev/blog/custom-binary-serialization.html#webpage",
            "url": "https://jbp.dev/blog/custom-binary-serialization.html",
            "inLanguage": "en",
            "name": "Custom Binary Serialization in C#",
            "isPartOf": {
                "@id": "https://jbp.dev/#website"
            },
            "about": {
                "@id": "https://jbp.dev/#organization"
            },
            "description": "A method for serializing unmanaged C# types into a binary format. Very fast and allocates as little memory as possible."
        }
    ]
}
  </script>
  <style>
main section > svg {
  max-width: 720px;
}
  </style>
</head>
<body>

<header>
  <h2>
      JB's BLOG
  </h2>
</header>

<nav>
  <section>
    <header>
      <h2>Breadcrumb</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/" title="jbp.dev - Homepage">Home</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-binary-serialization.html" title="Custom Binary Serialization in C#">Blog - Custom Binary Serialization</a>
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>DAWG series</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/blog/dawg-basics.html" title="Directed Acyclic Word Graphs - Part 1 - The Basics">The Basics</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-first-implementation.html" title="Directed Acyclic Word Graphs - Part 2 - First Implementation in C#">First Implementation in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-memory-footprint.html" title="Directed Acyclic Word Graphs - Part 3 - Reducing DAWG memory footprint">Reducing DAWG memory footprint</a>
      </li>
      <li>
        Using the DAWG to find spelling errors
      </li>
      <li>
        DAWG performance profiling - part 1
      </li>
      <li>
        Potential DAWG performance improvements
      </li>
      <li>
        Speedy DAWG
      </li>
      <li>
        DAWG performance profiling - part 2
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>Other posts</h2>
    </header>
    <ul>
      <li>
        <a href="https://jbp.dev/blog/custom-binary-serialization.html" title="Custom Binary Serialization in C#">Custom Binary Serialization in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/signing-net.html" title="Signing in .NET">Signing in .NET#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-app-config.html" title="Creating a custom configuration section in .NET">Creating a custom app.config</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-app-config.html" title="Creating a custom configuration section in .NET">Creating a custom app.config</a>
      </li>
    </ul>
  </section>
</nav>

<main>
<article>
  <header>
    <h1>Custom Binary Serialization in C#</h1>
  </header>
  
  <p>
    There are <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/" title="Serialization in .NET">plenty of ways</a>
    to serialize your data in C#.
    I'm going to explore one of these, <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization" title="Binary serialization">Binary serialization</a>,
    but instead of using .NET libraries, we're going to roll our own for fun. 
    Afterwards, I'll do some performance testing to see how it stacks up.
  </p>
  
  <section>
  <header>
  <h3>Requirements</h3>
  </header>
  <p>
    I use some new C# features and libraries.
  </p>
  <ul>
    <li>
      <p>
        .NET core 2.1 for
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netstandard-2.1" title="Span<T> Struct">
          <code>Span&lt;T&gt;</code>
        </a>.
        <br/>
        I'll also show a <em>hacky</em> work-around you can try for .NET Framework, it's pretty bad.
      </p>
      <aside>
        Further reading: 
        <a href="https://msdn.microsoft.com/en-us/magazine/mt814808.aspx">
          All About Span: Exploring a New .NET Mainstay
        </a>
        by
        <a href="https://devblogs.microsoft.com/pfxteam/author/toub/">
          Stephen Taub
        </a>
      </aside>
    </li>
    <li>
      <p>
        A compiler that supports C# 7.3 for the
        <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3#enhanced-generic-constraints" title="Enhanced generic constraints">
          <code>unmanaged</code> constraint
        </a>.
      </p>
      <aside>
        Further reading:
        <a href="https://devblogs.microsoft.com/premier-developer/dissecting-new-generics-constraints-in-c-7-3/">
          Dissecting new generic constraints in C# 7.3
        </a>
        by
        <a href="https://devblogs.microsoft.com/premier-developer/author/seteplia/">
          Sergey Tepliakov
        </a>
      </aside>
    </li>
    <li>
      <p>The NuGet package:
        <a href="https://www.nuget.org/packages/System.Runtime.CompilerServices.Unsafe/">
          System.Runtime.CompilerServices.Unsafe
        </a>
      </p>
      <aside>
        Further reading:
        <a href="https://mattwarren.org/2016/09/14/Subverting-.NET-Type-Safety-with-System.Runtime.CompilerServices.Unsafe/">
          Subverting .NET Type Safety with 'System.Runtime.CompilerServices.Unsafe'
        </a>
        by
        <a href="https://mattwarren.org/about/">
          Matt Warren
        </a>
      </aside>
    </li>
  </ul>
  </section>
  
  <section>
    <header>
      <h3>Writing to a stream</h3>
    </header>
    <section>
      <header>
        <h4 class="no-start-end-margin">Old busted</h4>
      </header>
      <p>
        The traditional way to write a struct to a stream has been to use the 
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal?view=netframework-4.8">
          Marshal class
        </a>
        and both
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.structuretoptr?view=netframework-4.8#System_Runtime_InteropServices_Marshal_StructureToPtr__1___0_System_IntPtr_System_Boolean_" title="StructureToPtr<T>(T, IntPtr, Boolean)">
          <code>StructureToPtr</code>
        </a>
        and 
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.sizeof?view=netframework-4.8#System_Runtime_InteropServices_Marshal_SizeOf__1___0_" title="SizeOf<T>(T)">
          SizeOf
        </a>
        to create a new <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> which gets passed to <code class="language-csharp"><span class="csharp-teal">Stream</span>.<span class="csharp-gold">Write</span></code>.
        If your objects are large, or if you have a lot of them, your performance and resource usage can be negatively affected.
      </p>
    </section>
    <section>
      <header>
        <h4 class="no-start-end-margin">New hotness</h4>
      </header>
      <p>
        With some trickery, <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;</code> can be made to point in-place to your existing struct.
        The main hurdle here is that we don't start off with a byte[], so how can we use any of <code class="language-csharp"><span class="csharp-teal">Span</span></code>'s constructors?
        That's where <code class="language-csharp">System.Runtime.CompilerServices.Unsafe</code> comes in.
        With the <code class="language-csharp"><span class="csharp-teal">AsPointer</span></code> method, we can convert our struct and use the constructor
        <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">Void</span>*, <span class="csharp-teal">Int32</span>)</code>.
      </p>
      <p>
        That constructor does require a length, so how do we get it?
        With the <code class="language-csharp">unmanaged</code> constraint, we can use the <code class="language-csharp"><span class="csharp-blue">sizeof</span></code> operator on our type.
        It's also a constraint for <code class="language-csharp"><span class="csharp-gold">AsPointer</span></code>, so we need it anyways.
      </p>
      <p>
        .NET Core 2.1 added a new overload to <code class="language-csharp"><span class="csharp-teal">Stream</span>.<span class="csharp-gold">Write</span></code>:
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream.write?view=netcore-2.1#System_IO_Stream_Write_System_ReadOnlySpan_System_Byte__" title="Write(ReadOnlySpan<Byte>)">
          <code class="language-csharp"><span class="csharp-gold">Write</span>(<span class="csharp-teal">ReadOnlySpan</span>&lt;<span class="csharp-blue">byte</span>&gt;)</code></a>.
        With this, we completely bypass using a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code>.
        We simply point to our existing struct, and trick the stream into thinking it's a collection of bytes.
      </p>
      <pre><code class="language-csharp"><span class="csharp-blue">public static unsafe void</span> <span class="csharp-gold">Write</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>, <span class="csharp-teal">T</span> <span class="csharp-navy">value</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">pointer</span> = <span class="csharp-teal">Unsafe</span>.<span class="csharp-gold">AsPointer</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">value</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;(<span class="csharp-navy">pointer</span>, <span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>));
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Write</span>(<span class="csharp-navy">span</span>);
}</code></pre>
    </section>
  </section>
  
  <section>
    <header>
      <h3>Reading from a stream</h3>
    </header>
    <p>
      This is very similar to writing. 
      We save one allocation by reading into our final memory location, and that also saves one copy operation.
    </p>
    <pre><code class="language-csharp"><span class="csharp-blue">public static unsafe</span> <span class="csharp-teal">T</span> <span class="csharp-gold">Read</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">result</span> = <span class="csharp-blue">default</span>(<span class="csharp-teal">T</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">pointer</span> = <span class="csharp-teal">Unsafe</span>.<span class="csharp-gold">AsPointer</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">result</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;(<span class="csharp-navy">pointer</span>, <span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>));
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Read</span>(<span class="csharp-navy">span</span>);
    <span class="csharp-purple">return</span> <span class="csharp-navy">result</span>;
}</code></pre>
  </section>
  
  <section>
    <header>
      <h3>We just want the code</h3>
    </header>
    <p>
      What you really came here for: <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/StreamExtensions.cs" title="StreamExtensions.cs">StreamExtensions.cs</a>
    </p>
  </section>
  
  <section>
    <header>
      <h3>Performance</h3>
    </header>
    <section>
      <header>
        <h4><a href="https://github.com/neuecc/ZeroFormatter">
            ZeroFormatter
          </a> benchmark</h4>
      </header>
      <p>
        Adapting the benchmark used by ZeroFormatter, I'll compare this custom serialization method against it in a few scenarios.
        It's not exactly a fair test, as all of my usages are hand-coded and ZeroFormatter has to use reflection.
      </p>
      <p>
        The code can all be found <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/ZeroFormatterBenchmark.cs" title="ZeroFormatterBenchmark.cs">on github</a>.
      </p>
      <svg viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><style>text{font-family:Times New Roman;font-size:1px}text.zero{fill:#ff8c00}text.cool{fill:#00f}text.case{font-size:2px}path{stroke:#000;fill:transparent;stroke-width:.1}path.cool,path.zero{fill:#ffa07a;stroke-width:0}path.cool{fill:#e0ffff}</style><text x="25" y="7">Legend:</text><text class="zero case" x="30" y="6">ZeroFormatter</text><text class="cool case" x="30" y="8">Custom</text><text class="case" x="30" y="12">Winner per category is colored</text><path class="zero" d="M1 60V29.19h1V60z"/><text x="1.8" y="28.9" transform="rotate(270 1.8 28.9)">30.81ms</text><path class="cool" d="M2 60V40.04h1V60z"/><text x="2.8" y="39.7" transform="rotate(270 2.8 39.7)">19.96ms</text><path class="zero" d="M4 60V44.79h1V60z"/><text x="4.8" y="44.5" transform="rotate(270 4.8 44.5)">15.21ms</text><path class="cool" d="M5 60V37.02h1V60z"/><text x="5.8" y="36.7" transform="rotate(270 5.8 36.7)">22.98ms</text><path class="zero" d="M7 60V10h1v50z"/><text x="7.8" y="9.7" transform="rotate(270 7.8 9.7)">50B</text><path class="cool" d="M8 60V34h1v26z"/><text x="8.8" y="33.7" transform="rotate(270 8.8 33.7)">26B</text><text class="cool" x="1" y="63.75" transform="rotate(290 1 63.75)">Serialize</text><text class="zero" x="3.9" y="64.75" transform="rotate(290 3.9 64.75)">Deserialize</text><text class="cool" x="6.9" y="64.5" transform="rotate(290 6.9 64.5)">Size (byte)</text><text class="case" x="3" y="67">Person</text><path class="zero" d="M11 60V45.48h1V60z"/><text x="11.8" y="45.2" transform="rotate(270 11.8 45.2)">14.52s</text><path class="cool" d="M12 60V37.99h1V60z"/><text x="12.8" y="37.7" transform="rotate(270 12.8 37.7)">22.01s</text><path class="zero" d="M14 60V42.72h1V60z"/><text x="14.8" y="42.4" transform="rotate(270 14.8 42.4)">17.28s</text><path class="cool" d="M15 60V38.4h1V60z"/><text x="15.8" y="38.1" transform="rotate(270 15.8 38.1)">21.60s</text><path class="zero" d="M17 60V11.17h1V60z"/><text x="17.8" y="10.9" transform="rotate(270 17.8 10.9)">48.83MB</text><path class="cool" d="M18 60V34.61h1V60z"/><text x="18.8" y="34.3" transform="rotate(270 18.8 34.3)">25.39MB</text><text class="zero" x="11" y="63.75" transform="rotate(290 11 63.75)">Serialize</text><text class="zero" x="13.9" y="64.75" transform="rotate(290 13.9 64.75)">Deserialize</text><text class="cool" x="16.9" y="64.5" transform="rotate(290 16.9 64.5)">Size (MB)</text><text class="case" x="12" y="67">Person[]</text><path class="zero" d="M21 60v-4.58h1V60z"/><text x="21.8" y="55.1" transform="rotate(270 21.8 55.1)">4.58ms</text><path class="cool" d="M22 60v-2.59h1V60z"/><text x="22.8" y="57.1" transform="rotate(270 22.8 57.1)">2.59ms</text><path class="zero" d="M24 60v-2.31h1V60z"/><text x="24.8" y="57.4" transform="rotate(270 24.8 57.4)">2.31ms</text><path class="cool" d="M25 60v-2.21h1V60z"/><text x="25.8" y="57.5" transform="rotate(270 25.8 57.5)">2.21ms</text><path class="zero" d="M27 60v-4h1v4z"/><text x="27.8" y="55.7" transform="rotate(270 27.8 55.7)">4B</text><path class="cool" d="M28 60v-4h1v4z"/><text x="28.8" y="55.7" transform="rotate(270 28.8 55.7)">4B</text><text class="cool" x="21" y="63.75" transform="rotate(290 21 63.75)">Serialize</text><text class="cool" x="23.9" y="64.75" transform="rotate(290 23.9 64.75)">Deserialize</text><text x="26.9" y="64.5" transform="rotate(290 26.9 64.5)">Size (byte)</text><text class="case" x="24" y="67">int</text><path class="zero" d="M31 60v-5.6h1V60z"/><text x="31.8" y="54.1" transform="rotate(270 31.8 54.1)">5.60ms</text><path class="cool" d="M32 60v-2.01h1V60z"/><text x="32.8" y="57.7" transform="rotate(270 32.8 57.7)">2.01ms</text><path class="zero" d="M34 60v-3.84h1V60z"/><text x="34.8" y="55.9" transform="rotate(270 34.8 55.9)">3.84ms</text><path class="cool" d="M35 60v-1.97h1V60z"/><text x="35.8" y="57.7" transform="rotate(270 35.8 57.7)">1.97ms</text><path class="zero" d="M37 60V48h1v12z"/><text x="37.8" y="47.7" transform="rotate(270 37.8 47.7)">12B</text><path class="cool" d="M38 60V48h1v12z"/><text x="38.8" y="47.7" transform="rotate(270 38.8 47.7)">12B</text><text class="cool" x="31" y="63.75" transform="rotate(290 31 63.75)">Serialize</text><text class="cool" x="33.9" y="64.75" transform="rotate(290 33.9 64.75)">Deserialize</text><text x="36.9" y="64.5" transform="rotate(290 36.9 64.5)">Size (byte)</text><text class="case" x="32" y="67">Vector3</text><path class="zero" d="M41 60V23.72h1V60z"/><text x="41.8" y="23.4" transform="rotate(270 41.8 23.4)">36.28s</text><path class="cool" d="M42 60V40.41h1V60z"/><text x="42.8" y="40.1" transform="rotate(270 42.8 40.1)">19.59s</text><path class="zero" d="M44 60V29.68h1V60z"/><text x="44.8" y="29.4" transform="rotate(270 44.8 29.4)">30.32s</text><path class="cool" d="M45 60V32.84h1V60z"/><text x="45.8" y="32.5" transform="rotate(270 45.8 32.5)">27.16s</text><path class="zero" d="M47 60V29.82h1V60z"/><text x="47.8" y="29.5" transform="rotate(270 47.8 29.5)">30.18x10MB</text><path class="cool" d="M48 60V29.82h1V60z"/><text x="48.8" y="29.5" transform="rotate(270 48.8 29.5)">30.18x10MB</text><text class="cool" x="41" y="63.75" transform="rotate(290 41 63.75)">Serialize</text><text class="cool" x="43.9" y="64.75" transform="rotate(290 43.9 64.75)">Deserialize</text><text x="46.9" y="64.5" transform="rotate(290 46.9 64.5)">Size (MB)</text><text class="case" x="43" y="67">string</text><path class="zero" d="M51 60V34.57h1V60z"/><text x="51.8" y="34.3" transform="rotate(270 51.8 34.3)">25.43x10ms</text><path class="cool" d="M52 60v-5.75h1V60z"/><text x="52.8" y="53.9" transform="rotate(270 52.8 53.9)">5.75x10ms</text><path class="zero" d="M54 60V39.92h1V60z"/><text x="54.8" y="39.6" transform="rotate(270 54.8 39.6)">20.08x10ms</text><path class="cool" d="M55 60v-2.07h1V60z"/><text x="55.8" y="57.6" transform="rotate(270 55.8 57.6)">2.07x10ms</text><path class="zero" d="M57 60v-1.18h1V60z"/><text x="57.8" y="58.52" transform="rotate(270 57.8 58.52)">1.18MB</text><path class="cool" d="M58 60v-1.18h1V60z"/><text x="58.8" y="58.52" transform="rotate(270 58.8 58.52)">1.18MB</text><text class="cool" x="51" y="63.75" transform="rotate(290 51 63.75)">Serialize</text><text class="cool" x="53.9" y="64.75" transform="rotate(290 53.9 64.75)">Deserialize</text><text x="56.9" y="64.5" transform="rotate(290 56.9 64.5)">Size (byte)</text><text class="case" x="51" y="67">Vector3[]</text><path d="M0 0v60h60V0z"/></svg>
      <p>
        As predicted, our serializer had excellent performance in the struct cases.
        <br/>
        We do lose out a few times. I'm guessing that in the case of <code class="language-csharp"><span class="csharp-blue">Person</span></code> and <code class="language-csharp"><span class="csharp-blue">Person</span>[]</code>, the UTF-8 encoding adds a lot of overhead.
      </p>
    </section>
    <section>
      <header>
        <h4>My use-case</h4>
      </header>
      <p>
        This is the data structure storing my DAWG from <a href="https://jbp.dev/blog/dawg-memory-footprint.html" title="Directed Acyclic Word Graphs - Part 3 - Reducing DAWG memory footprint">the third article</a> in that series.
        I'm going to test it against ZeroFormatter again, as well as .NET's
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netcore-2.1" title="BinaryFormatter Class">
          BinaryFormatter</a>.
        When loaded with a typical dictionary it would consume just over 1.4MB of memory.
      </p>
      <pre><code class="language-csharp"><span class="csharp-blue">private readonly int</span> _terminalNodeIndex;
<span class="csharp-blue">private readonly int</span> _rootNodeIndex;
<span class="csharp-blue">private readonly int</span>[] _firstChildEdgeIndex; // length: 38,745
<span class="csharp-blue">private readonly int</span>[] _edgesToNodeIndex; //length: 85,600
<span class="csharp-blue">private readonly char</span>[] _edgeCharacter; //length: 85,600
<span class="csharp-blue">private readonly ushort</span>[] _reachableTerminalNodes; // length: 38,744
<span class="csharp-blue">private readonly long</span>[] _wordCount; //length: 82,765</code></pre>
      <p>
        After some initial warm up to avoid JIT issues, I loaded the object from disk 1000 times with each method and here are the results.
      </p>
      <ul>
        <li>
            Custom: 495ms
        </li>
        <li>
          BinaryFormatter: 2162ms
        </li>
        <li>
          ZeroFormatter: 923ms
        </li>
      </ul>
      <p>
        I win!
        This shouldn't come as a surprise. 
        We're using a hand-coded serializer and working with its specialty, unmanaged arrays. 
        The other methods have to rely on reflection which can be a substantial burden, but they have the advantage of requiring less work to setup.
      </p>
      <p>
        The size of the files are also slightly different.
        <ul>
          <li>
            Custom: 1,322,620 bytes
          </li>
          <li>
            BinaryFormatter: 1,322,944 bytes
          </li>
          <li>
            ZeroFormatter: 1,408,252 bytes
          </li>
        </ul>
      </p>
      <p>
        Impressively, BinaryFormatter is very close to the custom format in size.
        I'm guessing the slight difference is from storing type information.
        The larger size of the ZeroFormatter file is almost assuredly from not converting the <code class="language-csharp"><span class="csharp-blue">char</span>[]</code> to UTF-8.
        It is a trade-off I've considered.
        With UTF-8 I save some bytes in the serialized format, but I have to allocate for a temporary <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> and take the performance hit of conversion.
        As we saw in the ZeroFormatter benchmark, with a large amount of small strings, this does add up.
      </p>
    </section>
  </section>
  <section>
    <header>
    <h3>Hack for .NET Framework</h3>
    </header>
    <p>
      Without <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">T</span>&gt;</code>,
      this method isn't feasible, we have to make do with <code class="language-csharp"><span class="csharp-gold">Write</span>(<span class="csharp-blue">byte</span>[], <span class="csharp-blue">int</span>, <span class="csharp-blue">int</span>)</code>.
      How can we convert an arbitrary type to a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code>?
      Unions aren't quite right, if the type's size is larger than a single byte, the <code class="language-csharp">Length</code> property is much too small and the
      <code class="language-csharp"><span class="csharp-teal">Stream</span></code> methods will complain when they perform bounds checking.
      Unsafe pointers won't do either, casting to a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> blows up.
      Using both, we can do some bad things...
    </p>
<pre><code class="language-csharp"><span class="csharp-blue">var</span> <span class="csharp-purple">wrapper</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">UnionArrayInt</span> {Typed = <span class="csharp-purple">value</span>};
<span class="csharp-gold">Write</span>(<span class="csharp-purple">wrapper</span>.Typed, <span class="csharp-purple">wrapper</span>.Bytes);

[<span class="csharp-teal">StructLayout</span>(<span class="csharp-teal">LayoutKind</span>.Explicit)]
<span class="csharp-blue">public struct</span> <span class="csharp-teal">UnionArrayInt</span>
{
    [<span class="csharp-teal">FieldOffset</span>(0)]
    <span class="csharp-blue">public readonly byte</span>[] Bytes;

    [<span class="csharp-teal">FieldOffset</span>(0)]
    <span class="csharp-blue">public int</span>[] Typed;
}

<span class="csharp-blue">public void</span> <span class="csharp-gold">Write</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-teal">T</span>[] <span class="csharp-navy">value</span>, <span class="csharp-blue">byte</span>[] <span class="csharp-navy">bytes</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">oldLength</span> = <span class="csharp-navy">value</span>.Length;
    Stream.<span class="csharp-gold">WriteInt32</span>(<span class="csharp-navy">oldLength</span>);
    
    <span class="csharp-blue">unsafe</span>
    {
        <span class="csharp-blue">fixed</span> (<span class="csharp-teal">T</span>* <span class="csharp-navy">typedPointer</span> = <span class="csharp-navy">value</span>)
        {
            <span class="csharp-blue">var</span> <span class="csharp-purple">intPointer</span> = (<span class="csharp-teal">IntPtr</span>*) <span class="csharp-purple">typedPointer</span>;
            <span class="csharp-purple">try</span>
            {
                *(<span class="csharp-navy">intPointer</span> - 1) = <span class="csharp-blue">new</span> <span class="csharp-teal">IntPtr</span>(<span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>) * <span class="csharp-navy">oldLength</span>);
                Stream.<span class="csharp-gold">Write</span>(<span class="csharp-navy">bytes</span>, 0, <span class="csharp-navy">bytes</span>.Length);
            }
            <span class="csharp-purple">finally</span>
            {
                *(<span class="csharp-navy">intPointer</span> - 1) = new <span class="csharp-teal">IntPtr</span>(<span class="csharp-navy">oldLength</span>);
            }
        }
    }
}</code></pre>
    <p>
      Unfortunately, you'll have to write a union struct for each type you want to use this way.
      I wasn't able to create a generic container.
    </p>
    <p>
      The magic part: <code class="language-csharp">*(<span class="csharp-purple">intPointer</span> - 1)</code>
      <br/>
      By using pointers to edit the length field of the array, I can trick <code class="language-csharp">Stream</code>'s methods into accepting it as a fake <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code>.
      <br/>
      It is important to note that I used IntPtr here not as an actual pointer, but as a representative of the word size of the processor. 
      Otherwise, when 32 bit you'd have to use <code class="language-csharp"><span class="csharp-blue">int</span></code>, while targeting 64 bit would require <code class="language-csharp"><span class="csharp-blue">long</span></code>.
    </p>
    <p>
      This relies on the memory layout of arrays.
      I don't know what kind of guarantee you can expect that it will always be at the same location.
      This is truly an example of: <blockquote><em>It works on my PC</em></blockquote>
    </p>
  </section>
  <section>
    <header>
      <h3>Concluding thoughts</h3>
    </header>
    <p>
      In the end it all depends on your requirements.
      Are you serializing bits and bytes? Do you have a need for speed?
      If so, this is a great way to do it.
      Otherwise, existing serialization libraries make it much easier to write maintainable code.
    </p>
    <p>If you missed the link to the code, here it is: <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/StreamExtensions.cs" title="StreamExtensions.cs">StreamExtensions.cs</a></p>
  </section>
</article>
</main>

<aside>
  <figure>
    <img src="https://jbp.dev/img/bird-small.jpg" alt="You caught me, I'm not a bird."/>
    <figcaption>Jean-Bernard Pellerin</figcaption>
  </figure>
  <p>
    Contact:
    I can be reached <a href="mailto:jbp@jbp.dev">by email</a>.
  </p>
</aside>

<footer>
  <p>
    <b><a href="https://jbp.dev/licenses.html">© 2019 Jean-Bernard Pellerin</a></b>
  </p>
</footer>  

</body>
</html>
