<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311168-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-143311168-1');
  </script>
  <title>Custom Binary Serialization in C#</title>
  <meta name="author" content="Jean-Bernard Pellerin"/>
  <meta name="description" content="A method for serializing unmanaged C# types into a binary format. Very fast and allocates as little memory as possible."/>
  <meta name="generator" content="100% organic human"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="https://jbp.dev/blog/custom-binary-serialization.html"/>
  <link rel="license" href="https://jbp.dev/licenses.html"/>
  <link rel="preload" as="style" href="https://jbp.dev/css/normalize.css" onload="this.onload=null;this.rel='stylesheet'"/>
  <noscript><link rel="stylesheet" href="https://jbp.dev/css/normalize.css"/></noscript>
  <link rel="preload" as="style" href="https://jbp.dev/css/jeanbern.css" onload="this.onload=null;this.rel='stylesheet'"/>
  <noscript><link rel="stylesheet" href="https://jbp.dev/css/jeanbern.css"/></noscript>
  <link rel="preload" as="image" href="https://jbp.dev/img/flower-compressed.jpg" media="(min-width: 1024px)"/>
  <link rel="preload" as="image" href="https://jbp.dev/img/bird-small.jpg"/>
  <style>
body{font-family:Roboto, sans-serif;font-stretch:normal;font-style:normal;font-weight:400;display:grid;height:100vh;grid-gap:1em;background:#f8f8f8}body > aside > figure{margin:0}body > nav li{padding-top:.5em}body > header{grid-area:header;text-align:center;color:#fff}body > header > h2{font-size:2em;margin:.67em 0}body > nav{grid-area:nav;border:thick double #32a1ce;margin-left:.5em;padding:.5em;background:#f8f8f8}body > nav h2{margin-block-end:0}body > main{min-width:320px;grid-area:content;color:#333}body > aside{grid-area:side;border:thick double #32a1ce;margin-right:.5em;padding:.5em;background:#f8f8f8}body > footer{grid-area:footer;text-align:center}body main article{height:calc(100%-2em)}main article{padding:1em;background:#fff}pre{line-height:initial;overflow-x:auto}main section{margin-bottom:.5em;margin-top:.5em}main header > *{margin-top:.25em;margin-left:1em}main header > h1,main header > h2,main header > h3,main header > h4,main header > h5,main header > h6{margin-left:0;margin-bottom:0}main header > h1:first-child,main header > h2:first-child,main header > h3:first-child,main header > h4:first-child,main header > h5:first-child,main header > h6:first-child{display:inline-block}main header > a.bookmark{margin-left:0;padding-left:.5em}a.bookmark::after{content:url("data:image/svg+xml; utf8, <svg xmlns='http://www.w3.org/2000/svg' viewBox='00512512'><path d='M326.612185.391c59.74759.80958.927155.698.36214.59-.11.12-.24.25-.36.37l-67.267.2c-59.2759.27-155.69959.262-214.960-59.27-59.26-59.27-155.70-214.96l37.106-37.106c9.84-9.8426.786-3.327.29410.606.64817.7223.82635.5279.6952.7211.9865.822.56712.262-3.78316.612l-13.08713.087c-28.02628.026-28.90573.66-1.155101.9628.02428.57974.08628.749102.325.51l67.2-67.19c28.191-28.19128.073-73.7570-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.03716.037001-6.947-12.606c-.396-10.5673.348-21.45611.698-29.806l21.054-21.055c5.521-5.52114.182-6.19920.584-1.731a152.482152.48200120.52217.197zM467.54744.449c-59.261-59.262-155.69-59.27-214.960l-67.267.2c-.12.12-.25.25-.36.37-58.56658.892-59.387154.781.36214.59a152.454152.45400020.52117.196c6.4024.46815.0643.78920.584-1.731l21.054-21.055c8.35-8.3512.094-19.23911.698-29.806a16.03716.037000-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.6390-101.83l67.2-67.19c28.239-28.23974.3-28.069102.325.5127.7528.326.87273.934-1.155101.96l-13.08713.087c-4.354.35-5.76910.79-3.78316.6125.86417.1949.04234.9999.6952.721.50913.90617.45420.44627.29410.606l37.106-37.106c59.271-59.25959.271-155.699.001-214.959z'/></svg>");width:1em;display:inline-block}main header cite{float:right}cite:before{content:'('}cite:after{content:')'}code.language-csharp{font-family:consolas, monaco, monospace;color:#000;white-space:pre}body > nav ol,body > nav ul{margin-block-start:0;padding-inline-start:1em}main ul,main ol,main p{margin-top:.5em;margin-bottom:0}main section > p,main section > figure,main section > header,main section > svg,main section > pre,main section > details,main article.inner-article > *{margin-left:1em}main section > header:first-child,main article.inner-article > header:first-child{margin-left:0}main section > svg{max-width:720px}@media (max-width: 768px){body{grid-template-areas:"header" "nav" "content" "side" "footer";grid-template-columns:1fr;grid-template-rows:auto auto minmax(auto,1fr) 200px auto}body > nav{display:flex;margin-right:.5em}body > nav > *{margin-left:.5em;margin-right:.5em}}@media (max-width: 1024px){body > aside > figure{margin-inline-end:.5em}body > aside > figure img{max-width:200px}body > aside{display:flex;margin-left:.5em}}@media (min-width: 768px) and (max-width: 1024px){body{grid-template-areas:"header header" "nav content" "side side" "footer footer";grid-template-columns:200px 1fr;grid-template-rows:auto 1fr 200px auto}body > main{margin-right:.5em}body > nav{height:min-content}}@media (min-width: 1024px){body{grid-template-areas:"header header header" "nav content side" "footer footer footer";grid-template-columns:200px 1fr 200px;grid-template-rows:auto 1fr auto;background:url(https://jbp.dev/img/flower-compressed.jpg) no-repeat top center fixed;background-size:cover}body > aside > figure img{width:100%}body > nav,body > aside{height:min-content}}
  </style>
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
  {
    "@type": "Person",
    "@id": "https://jbp.dev/about/JB/#Person",
    "name": "Jean-Bernard Pellerin",
    "url": "https://jbp.dev/JB/",
    "email": "jeanbern@ualberta.ca",
    "familyName": "Pellerin",
    "givenName": "Jean-Bernard",
    "nationality": {
      "@type": "Country",
      "name": "Canada"
    },
    "alternateName": "JB",
    "mainEntityOfPage": "https://jbp.dev/about/JB.html",
    "sameAs": [
      "https://www.facebook.com/jbpellerin",
      "https://www.linkedin.com/in/jean-bernard-pellerin-026bbb23",
      "https://twitter.com/jeanbpellerin"
    ]
  },
  {
    "@type": "WebSite",
    "@id": "https://jbp.dev/#website",
    "name": "jbp.dev",
    "url": "https://jbp.dev/",
    "accessibilityControl": [
      "fullMouseControl",
      "fullKeyboardControl"
    ],
    "accessibilityFeature": [
      "highContrastAudio/noBackground",
      "highContrastDisplay",
      "displayTransformability",
      "annotations",
      "bookmarks",
      "index",
      "readingOrder",
      "structuralNavigation",
      "unlocked",
      "alternativeText",
      "describedMath",
      "longDescription"
    ],
    "accessibilityHazard": "none",
    "author": "https://jbp.dev/about/JB/#Person",
    "copyrightHolder": "https://jbp.dev/about/JB/#Person",
    "copyrightYear": "2019",
    "dateCreated": "2019-07-10",
    "interactivityType": "expositive",
    "isAccessibleForFree": "true",
    "isFamilyFriendly": "true",
    "license": "https://jbp.dev/licenses.html",
    "publisher": "https://jbp.dev/about/JB/#Person",
    "description": "Jean-Bernard Pellerin's personal website"
  },
  {
    "@type": "WPHeader",
    "name": "header",
    "@id": "https://jbp.dev/#header",
    "cssSelector": "body > header"
  },
  {
    "@type": "SiteNavigationElement",
    "name": "nav",
    "@id": "https://jbp.dev/#nav",
    "cssSelector": "body > nav"
  },
  {
    "@type": "WPSideBar",
    "name": "sidebar",
    "@id": "https://jbp.dev/#sidebar",
    "cssSelector": "body > aside"
  },
  {
    "@type": "WPFooter",
    "name": "footer",
    "@id": "https://jbp.dev/#footer",
    "cssSelector": "body > footer"
  },
  {
      "@type": "WebPage",
      "@id": "https://jbp.dev/blog/custom-binary-serialization.html#webpage",
      "url": "https://jbp.dev/blog/custom-binary-serialization.html",
      "inLanguage": "en",
      "name": "Custom Binary Serialization in C#",
      "isPartOf": {
          "@id": "https://jbp.dev/#website"
      },
      "description": "A method for serializing unmanaged C# types into a binary format. Very fast and allocates as little memory as possible."
  }]
}
  </script>
</head>
<body>

<header>
  <h2>
      JB's BLOG
  </h2>
</header>

<nav>
  <section>
    <header>
      <h2>Breadcrumb</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/" title="jbp.dev - Homepage">Home</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-binary-serialization.html" title="Custom Binary Serialization in C#">Blog - Custom Binary Serialization</a>
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>DAWG series</h2>
    </header>
    <ol>
      <li>
        <a href="https://jbp.dev/blog/dawg-basics.html" title="Directed Acyclic Word Graphs - Part 1 - The Basics">The Basics</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-first-implementation.html" title="Directed Acyclic Word Graphs - Part 2 - First Implementation in C#">First Implementation in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/dawg-memory-footprint.html" title="Directed Acyclic Word Graphs - Part 3 - Reducing DAWG memory footprint">Reducing DAWG memory footprint</a>
      </li>
      <li>
        Using the DAWG to find spelling errors
      </li>
      <li>
        DAWG performance profiling - part 1
      </li>
      <li>
        Potential DAWG performance improvements
      </li>
      <li>
        Speedy DAWG
      </li>
      <li>
        DAWG performance profiling - part 2
      </li>
    </ol>
  </section>
  <section>
    <header>
      <h2>Other posts</h2>
    </header>
    <ul>
      <li>
        <a href="https://jbp.dev/blog/custom-binary-serialization.html" title="Custom Binary Serialization in C#">Custom Binary Serialization in C#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/signing-net.html" title="Signing in .NET">Signing in .NET#</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/custom-app-config.html" title="Creating a custom configuration section in .NET">Creating a custom app.config</a>
      </li>
      <li>
        <a href="https://jbp.dev/blog/net35-on-windows-server.html" title="How to install .NET 3.5 on Windows Server without the iso.">Installing .NET 3.5 on Windows Server 2016</a>
      </li>
    </ul>
  </section>
</nav>

<main>
<article>
  <header>
    <h1>Custom Binary Serialization in C#</h1>
    <p><em>Updated 2019-07-11</em></p>
  </header>
  
  <p>
    There are <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/" title="Serialization in .NET">plenty of ways</a>
    to serialize your data in C#.
    I'm going to explore one of these, <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization" title="Binary serialization">Binary serialization</a>,
    but instead of using .NET libraries, we're going to roll our own for fun. 
    Afterwards, I'll do some performance testing to see how it stacks up.
  </p>
  <p>
    In this article I'll be trying to write directly into the memory location of some structs and primitives.
    By avoiding extra copying, allocation, and call stack depth, I can hopefully serialize my data faster.
  </p>
  <section>
  <header>
  <h3>Requirements</h3>
  </header>
  <p>
    I use some new C# features and libraries.
  </p>
  <ul>
    <li>
      <p>
        .NET core 2.1 for
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netstandard-2.1" title="Span<T> Struct">
          <code>Span&lt;T&gt;</code>
        </a>.
        <br/>
        I'll also show a <em>hacky</em> work-around you can try for .NET Framework, it's pretty bad.
      </p>
      <aside>
        Further reading: 
        <a href="https://msdn.microsoft.com/en-us/magazine/mt814808.aspx">
          All About Span: Exploring a New .NET Mainstay
        </a>
        by
        <a href="https://devblogs.microsoft.com/pfxteam/author/toub/">
          Stephen Taub
        </a>
      </aside>
    </li>
    <li>
      <p>
        A compiler that supports C# 7.3 for the
        <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3#enhanced-generic-constraints" title="Enhanced generic constraints">
          <code>unmanaged</code> constraint
        </a>.
      </p>
      <aside>
        Further reading:
        <a href="https://devblogs.microsoft.com/premier-developer/dissecting-new-generics-constraints-in-c-7-3/">
          Dissecting new generic constraints in C# 7.3
        </a>
        by
        <a href="https://devblogs.microsoft.com/premier-developer/author/seteplia/">
          Sergey Tepliakov
        </a>
      </aside>
    </li>
    <li>
      <p>(Optional) The NuGet package:
        <a href="https://www.nuget.org/packages/System.Runtime.CompilerServices.Unsafe/">
          System.Runtime.CompilerServices.Unsafe
        </a>
      </p>
      <aside>
        Further reading:
        <a href="https://mattwarren.org/2016/09/14/Subverting-.NET-Type-Safety-with-System.Runtime.CompilerServices.Unsafe/">
          Subverting .NET Type Safety with 'System.Runtime.CompilerServices.Unsafe'
        </a>
        by
        <a href="https://mattwarren.org/about/">
          Matt Warren
        </a>
      </aside>
    </li>
  </ul>
  </section>
  
  <section>
    <header>
      <h3>Writing to a stream</h3>
    </header>
    <section>
      <header>
        <h4>Old busted</h4>
      </header>
      <p>
        The traditional way to write a struct to a stream has been to use the 
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal?view=netframework-4.8">
          Marshal class
        </a>
        and both
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.structuretoptr?view=netframework-4.8#System_Runtime_InteropServices_Marshal_StructureToPtr__1___0_System_IntPtr_System_Boolean_" title="StructureToPtr<T>(T, IntPtr, Boolean)">
          <code>StructureToPtr</code>
        </a>
        and 
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.sizeof?view=netframework-4.8#System_Runtime_InteropServices_Marshal_SizeOf__1___0_" title="SizeOf<T>(T)">
          SizeOf
        </a>
        to create a new <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> which gets passed to <code class="language-csharp"><span class="csharp-teal">Stream</span>.<span class="csharp-gold">Write</span></code>.
        If your objects are large, or if you have a lot of them, your performance and resource usage can be negatively affected.
      </p>
    </section>
    <section>
      <header>
        <h4>New hotness</h4>
      </header>
      <p>
        First, some credit to others who have helped me refine this code. Thanks to their suggestions I was able to convert this from the unsafe form to a new safe version.
      </p>
      <ul>
        <li>
            <a href="https://github.com/benaadams">Ben Adams</a><sup><a href="https://www.reddit.com/r/dotnet/comments/cbaisd/using_spant_and_the_unmanaged_constraint_for/ete81pk/" title="Ben Adams' comment on reddit part 1">[1]</a></sup><sup><a href="https://www.reddit.com/r/dotnet/comments/cbaisd/using_spant_and_the_unmanaged_constraint_for/eteafc3/" title="Ben Adams' comment on reddit part 2">[2]</a></sup>
            and reddit user <a href="https://www.reddit.com/user/ThadeeusMaximus">ThadeeusMaximus</a><sup><a href="https://www.reddit.com/r/csharp/comments/cba8su/using_spant_and_the_unmanaged_constraint_for/etec3qu/" title="ThadeeusMaximus' comment on reddit">[3]</a></sup>
            brought how to avoid an
            <code class="language-csharp"><span class="csharp-blue">unsafe</span></code>
            context by using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal?view=netstandard-2.1">MemoryMarshal</a>.
          </li>
          <li>
            Reddit user <a href="https://www.reddit.com/user/ILMTitan">ILMTitan</a><sup><a href="https://www.reddit.com/r/csharp/comments/cba8su/using_spant_and_the_unmanaged_constraint_for/etek2sf/" title="ILMTitan's comment on reddit">[4]</a></sup>
            demonstrated a safe version of <code><span class="csharp-blue">stackalloc</span></code>.
          </li>
      </ul>
      <p>
        .NET Core 2.1 added a new overload 
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream.write?view=netcore-2.1#System_IO_Stream_Write_System_ReadOnlySpan_System_Byte__" title="Write(ReadOnlySpan<Byte>)">
          <code class="language-csharp"><span class="csharp-teal">Stream</span>.<span class="csharp-gold">Write</span>(<span class="csharp-teal">ReadOnlySpan</span>&lt;<span class="csharp-blue">byte</span>&gt;)</code></a>.
        With this, we will bypass creating a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> and converting our struct.
        We simply point to our existing struct, and trick the stream into thinking it's a collection of bytes.
      </p>
      <p>
        With some trickery, <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;</code> can be made to point in-place to your existing struct.
        The main hurdle here is that we don't start off with a byte[], so how can we use any of <code class="language-csharp"><span class="csharp-teal">Span</span></code>'s constructors?
        There are two options, I'll explain how to use them and the different trade-offs involved.
      </p>
      <ol>
        <li>
          <code class="language-csharp">System.Runtime.CompilerServices.Unsafe</code>
          <p>
            With the <code class="language-csharp"><span class="csharp-teal">AsPointer</span></code> method, we can convert our struct and use the constructor
            <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">Void</span>*, <span class="csharp-teal">Int32</span>)</code>.
            It does require a length, so how do we get it?
            With the <code class="language-csharp">unmanaged</code> constraint, we can use the <code class="language-csharp"><span class="csharp-blue">sizeof</span></code> operator on our type.
            It's also a constraint for <code class="language-csharp"><span class="csharp-gold">AsPointer</span></code>, so we need it anyways.
          </p>
          <pre><code class="language-csharp"><span class="csharp-blue">public static unsafe void</span> <span class="csharp-gold">Write</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>, <span class="csharp-teal">T</span> <span class="csharp-navy">value</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">pointer</span> = <span class="csharp-teal">Unsafe</span>.<span class="csharp-gold">AsPointer</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">value</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;(<span class="csharp-navy">pointer</span>, <span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>));
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Write</span>(<span class="csharp-navy">span</span>);
}</code></pre>
        </li>
        <li>
          <code class="language-csharp"><span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">CreateSpan</span>, <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">AsBytes</span></code>
          <p>
            With these, we avoid the unsafe context and some potential memory issues.
          </p>
          <pre><code class="language-csharp"><span class="csharp-blue">public static void</span> <span class="csharp-gold">Write</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>, <span class="csharp-teal">T</span> <span class="csharp-navy">value</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">tSpan</span> = <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">CreateSpan</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">value</span>, 1);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">AsBytes</span>(<span class="csharp-navy">tSpan</span>);
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Write</span>(<span class="csharp-navy">span</span>);
}</code></pre>
        </li>
      </ol>
      
    </section>
  </section>
  
  <section>
    <header>
      <h3>Reading from a stream</h3>
    </header>
    <p>
      Again, we have two options.
      Both save one allocation by reading into our final memory location, and avoid a copy operation by not using an intermediate byte[].
    </p>
    <ol>
      <li>
        <p>
          Unsafe:
          <pre><code class="language-csharp"><span class="csharp-blue">public static unsafe</span> <span class="csharp-teal">T</span> <span class="csharp-gold">Read</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">result</span> = <span class="csharp-blue">default</span>(<span class="csharp-teal">T</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">pointer</span> = <span class="csharp-teal">Unsafe</span>.<span class="csharp-gold">AsPointer</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">result</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">byte</span>&gt;(<span class="csharp-navy">pointer</span>, <span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>));
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Read</span>(<span class="csharp-navy">span</span>);
    <span class="csharp-purple">return</span> <span class="csharp-navy">result</span>;
}</code></pre>
        </p>
      </li>
      <li>
        <p>
          Safe:
          <pre><code class="language-csharp"><span class="csharp-blue">public static</span> <span class="csharp-teal">T</span> <span class="csharp-gold">Read</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">result</span> = <span class="csharp-blue">default</span>(<span class="csharp-teal">T</span>);
    <span class="csharp-blue">var</span> <span class="csharp-navy">tSpan</span> = <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">CreateSpan</span>(<span class="csharp-blue">ref</span> <span class="csharp-navy">result</span>, 1);
    <span class="csharp-blue">var</span> <span class="csharp-navy">span</span> = <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">AsBytes</span>(<span class="csharp-navy">tSpan</span>);
    <span class="csharp-navy">stream</span>.<span class="csharp-gold">Read</span>(<span class="csharp-navy">span</span>);
    <span class="csharp-purple">return</span> <span class="csharp-navy">result</span>;
}</code></pre>
        </p>
      </li>
    </ol>
  </section>
  
  <section>
    <header>
      <h3>Differences between the two methods</h3>
    </header>
    <p>
      Suprisingly, <code class="language-csharp"><span class="csharp-teal">MemoryMarshal</span></code> actually uses <code class="language-csharp">System.Runtime.CompilerServices.Unsafe</code> behind the scenes
      (<a href="https://github.com/dotnet/corefx/blob/release/3.0/src/Common/src/CoreLib/System/Runtime/InteropServices/MemoryMarshal.Fast.cs#L35" title="MemoryMarshal.Fast.cs line 35">corefx source</a>).
      <br/>
      The big difference is that the generic constraint there is on
      <code class="language-csharp"><span class="csharp-teal">T</span> : <span class="csharp-teal">struct</span></code>
      and not
      <code class="language-csharp"><span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span></code>
      like our code.
      Because of this they have to make sure that
      <code class="language-csharp"><span class="csharp-teal">RuntimeHelpers</span>.<span class="csharp-gold">IsReferenceOrContainsReferences</span>&lt;<span class="csharp-teal">T</span>&gt;()</code>
      is false.
    </p>
    <p>
      I found the code for it <a href="https://github.com/dotnet/coreclr/blob/release/3.0/src/vm/jitinterface.cpp#L7507" title="getILIntrinsicImplementationForRuntimeHelpers">deep in the JIT interface</a>.
    </p>
<pre><code>bool getILIntrinsicImplementationForRuntimeHelpers(MethodDesc * ftn,
    CORINFO_METHOD_INFO * methInfo)
{
...
    if (!methodTable-&gt;IsValueType() || methodTable-&gt;ContainsPointers())
    {
        methInfo->ILCode = const_cast&lt;BYTE*&gt;(returnTrue);
    }
    else
    {
        methInfo-&gt;ILCode = const_cast&lt;BYTE*&gt;(returnFalse);
    }
...
}</code></pre>
    <p>
      <a href="https://github.com/dotnet/corefx/blob/release/3.0/src/Common/src/CoreLib/System/Type.cs#L110"><code class="language-csharp"><span class="csharp-teal">Type</span>.IsValueType</code></a>
      calls <a href="https://github.com/dotnet/corefx/blob/release/3.0/src/Common/src/CoreLib/System/Type.Helpers.cs#L319"><code class="language-csharp">IsSubclassOf</code></a>, 
      a small method that should have no problems executing quickly.
      <a href="https://github.com/dotnet/coreclr/blob/b614f4f5529296cac834e54f2fa4bc540a61a04d/src/vm/methodtable.h#L1811"><code class="language-csharp"><span class="csharp-gold">ContainsPointers</span>()</code></a>
      is a flag check from C++ code and is equally speedy.
    </p>
    <p>
      So the first call to <code><span class="csharp-gold">IsReferenceOrContainsReferences</span></code> is fairly cheap, and the JIT compiler may be able to optimize it out afterwards.
    </p>
  </section>
  
  <section>
    <header>
      <h3>We just want the code</h3>
    </header>
    <p>
      What you really came here for: <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/StreamExtensions.cs" title="StreamExtensions.cs">StreamExtensions.cs</a>
    </p>
  </section>
  
  <section>
    <header>
      <h3>Performance</h3>
    </header>
    
    <section>
      <header>
        <h4>Safe vs Unsafe</h4>
      </header>
      <p>
        I ran a benchmark 4 times.
        The first run was excluded to warm up the profiler.
        The median of the other 3 was kept as the result.
        I checked to make sure there were no weird outliers in the data, everything looks good.
      </p>
      <details>
        <summary>
          The raw data if you care for it.
        </summary>
        <p>
          This was run after I'd generated my graph.
          The SVG is already minified and I didn't keep a copy of the original.
          The results are similar, though a bit faster for all cases. I'm going to blame corporate anti-virus.
        </p>
<pre>Person
ZeroFormatter
      Serialize		24.6626 ms
    Deserialize		15.042 ms
    Binary Size		50.00 B
SafeFormatter
      Serialize		22.2043 ms
    Deserialize		23.3115 ms
    Binary Size		26.00 B
UnsafeFormatter
      Serialize		23.8769 ms
    Deserialize		24.2574 ms
    Binary Size		26.00 B
Person[]
ZeroFormatter
      Serialize		14486.7296 ms
    Deserialize		17258.767 ms
    Binary Size		48.83 KB
SafeFormatter		
      Serialize		23333.3715 ms
    Deserialize		24200.0206 ms
    Binary Size		25.39 KB
UnsafeFormatter
      Serialize		23882.1373 ms
    Deserialize		24917.1850 ms
    Binary Size		25.39 KB
int
ZeroFormatter
      Serialize		2.9242 ms
    Deserialize		1.6953 ms
    Binary Size		4.00 B
SafeFormatter
      Serialize		1.7977 ms
    Deserialize		1.9589 ms
    Binary Size		4.00 B
UnsafeFormatter
      Serialize		1.8955 ms
    Deserialize		1.8404 ms
    Binary Size		4.00 B
Vector3
ZeroFormatter
      Serialize		4.7405 ms
    Deserialize		3.0243 ms
    Binary Size		12.00 B
SafeFormatter
      Serialize		1.9061 ms
    Deserialize		2.3206 ms
    Binary Size		12.00 B
UnsafeFormatter
      Serialize		2.0275 ms
    Deserialize		1.9824 ms
    Binary Size		12.00 B
string
ZeroFormatter
      Serialize		34284.1008 ms
    Deserialize		31301.6707 ms
    Binary Size		301.84 KB
SafeFormatter
      Serialize		19599.1895 ms
    Deserialize		29779.7524 ms
    Binary Size		301.84 KB
UnsafeFormatter
      Serialize		19569.0796 ms
    Deserialize		30918.9688 ms
    Binary Size		301.84 KB
Vector3[]
ZeroFormatter
      Serialize		260.0052 ms
    Deserialize		200.6082 ms
    Binary Size		1.18 KB
SafeFormatter
      Serialize		6.1998 ms
    Deserialize		18.7903 ms
    Binary Size		1.18 KB
UnsafeFormatter
      Serialize		7.4503 ms
    Deserialize		20.1956 ms
    Binary Size		1.18 KB</pre>
      </details>
      <p>
        The two methods are neck and neck.
        It looks like the safe version is a teeny bit faster, but it's so small that I'd consider it observational error.
      </p>
      <p>
        Therefore, I would stick with the safe version.
        Glad I tested both!
      </p>
    </section>
    
    <section>
      <header>
        <h4>ZeroFormatter benchmark</h4>
      </header>
      <p>
        Adapting the benchmark used by <a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a>, I'll compare this custom serialization method against it in a few scenarios.
        It's not exactly a fair test, as all of my usages are hand-coded and ZeroFormatter has to use reflection.
      </p>
      <p>
        The code can all be found <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/ZeroFormatterBenchmark.cs" title="ZeroFormatterBenchmark.cs">on github</a>.
      </p>
      <svg viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><style>text{font-family:Times New Roman;font-size:1px}text.zero{fill:#ff8c00}text.cool{fill:#00f}text.case{font-size:2px}path{stroke:#000;fill:transparent;stroke-width:.1}path.cool,path.zero{fill:#ffa07a;stroke-width:0}path.cool{fill:#e0ffff}</style><text x="25" y="7">Legend:</text><text class="zero case" x="30" y="6">ZeroFormatter</text><text class="cool case" x="30" y="8">Custom</text><text class="case" x="30" y="12">Winner per category is colored</text><path class="zero" d="M1 60V29.19h1V60z"/><text x="1.8" y="28.9" transform="rotate(270 1.8 28.9)">30.81ms</text><path class="cool" d="M2 60V40.04h1V60z"/><text x="2.8" y="39.7" transform="rotate(270 2.8 39.7)">19.96ms</text><path class="zero" d="M4 60V44.79h1V60z"/><text x="4.8" y="44.5" transform="rotate(270 4.8 44.5)">15.21ms</text><path class="cool" d="M5 60V37.02h1V60z"/><text x="5.8" y="36.7" transform="rotate(270 5.8 36.7)">22.98ms</text><path class="zero" d="M7 60V10h1v50z"/><text x="7.8" y="9.7" transform="rotate(270 7.8 9.7)">50B</text><path class="cool" d="M8 60V34h1v26z"/><text x="8.8" y="33.7" transform="rotate(270 8.8 33.7)">26B</text><text class="cool" x="1" y="63.75" transform="rotate(290 1 63.75)">Serialize</text><text class="zero" x="3.9" y="64.75" transform="rotate(290 3.9 64.75)">Deserialize</text><text class="cool" x="6.9" y="64.5" transform="rotate(290 6.9 64.5)">Size (byte)</text><text class="case" x="3" y="67">Person</text><path class="zero" d="M11 60V45.48h1V60z"/><text x="11.8" y="45.2" transform="rotate(270 11.8 45.2)">14.52s</text><path class="cool" d="M12 60V37.99h1V60z"/><text x="12.8" y="37.7" transform="rotate(270 12.8 37.7)">22.01s</text><path class="zero" d="M14 60V42.72h1V60z"/><text x="14.8" y="42.4" transform="rotate(270 14.8 42.4)">17.28s</text><path class="cool" d="M15 60V38.4h1V60z"/><text x="15.8" y="38.1" transform="rotate(270 15.8 38.1)">21.60s</text><path class="zero" d="M17 60V11.17h1V60z"/><text x="17.8" y="10.9" transform="rotate(270 17.8 10.9)">48.83KB</text><path class="cool" d="M18 60V34.61h1V60z"/><text x="18.8" y="34.3" transform="rotate(270 18.8 34.3)">25.39KB</text><text class="zero" x="11" y="63.75" transform="rotate(290 11 63.75)">Serialize</text><text class="zero" x="13.9" y="64.75" transform="rotate(290 13.9 64.75)">Deserialize</text><text class="cool" x="16.9" y="64.5" transform="rotate(290 16.9 64.5)">Size (KB)</text><text class="case" x="12" y="67">Person[]</text><path class="zero" d="M21 60v-4.58h1V60z"/><text x="21.8" y="55.1" transform="rotate(270 21.8 55.1)">4.58ms</text><path class="cool" d="M22 60v-2.59h1V60z"/><text x="22.8" y="57.1" transform="rotate(270 22.8 57.1)">2.59ms</text><path class="zero" d="M24 60v-2.31h1V60z"/><text x="24.8" y="57.4" transform="rotate(270 24.8 57.4)">2.31ms</text><path class="cool" d="M25 60v-2.21h1V60z"/><text x="25.8" y="57.5" transform="rotate(270 25.8 57.5)">2.21ms</text><path class="zero" d="M27 60v-4h1v4z"/><text x="27.8" y="55.7" transform="rotate(270 27.8 55.7)">4B</text><path class="cool" d="M28 60v-4h1v4z"/><text x="28.8" y="55.7" transform="rotate(270 28.8 55.7)">4B</text><text class="cool" x="21" y="63.75" transform="rotate(290 21 63.75)">Serialize</text><text class="cool" x="23.9" y="64.75" transform="rotate(290 23.9 64.75)">Deserialize</text><text x="26.9" y="64.5" transform="rotate(290 26.9 64.5)">Size (byte)</text><text class="case" x="24" y="67">int</text><path class="zero" d="M31 60v-5.6h1V60z"/><text x="31.8" y="54.1" transform="rotate(270 31.8 54.1)">5.60ms</text><path class="cool" d="M32 60v-2.01h1V60z"/><text x="32.8" y="57.7" transform="rotate(270 32.8 57.7)">2.01ms</text><path class="zero" d="M34 60v-3.84h1V60z"/><text x="34.8" y="55.9" transform="rotate(270 34.8 55.9)">3.84ms</text><path class="cool" d="M35 60v-1.97h1V60z"/><text x="35.8" y="57.7" transform="rotate(270 35.8 57.7)">1.97ms</text><path class="zero" d="M37 60V48h1v12z"/><text x="37.8" y="47.7" transform="rotate(270 37.8 47.7)">12B</text><path class="cool" d="M38 60V48h1v12z"/><text x="38.8" y="47.7" transform="rotate(270 38.8 47.7)">12B</text><text class="cool" x="31" y="63.75" transform="rotate(290 31 63.75)">Serialize</text><text class="cool" x="33.9" y="64.75" transform="rotate(290 33.9 64.75)">Deserialize</text><text x="36.9" y="64.5" transform="rotate(290 36.9 64.5)">Size (byte)</text><text class="case" x="32" y="67">Vector3</text><path class="zero" d="M41 60V23.72h1V60z"/><text x="41.8" y="23.4" transform="rotate(270 41.8 23.4)">36.28s</text><path class="cool" d="M42 60V40.41h1V60z"/><text x="42.8" y="40.1" transform="rotate(270 42.8 40.1)">19.59s</text><path class="zero" d="M44 60V29.68h1V60z"/><text x="44.8" y="29.4" transform="rotate(270 44.8 29.4)">30.32s</text><path class="cool" d="M45 60V32.84h1V60z"/><text x="45.8" y="32.5" transform="rotate(270 45.8 32.5)">27.16s</text><path class="zero" d="M47 60V29.82h1V60z"/><text x="47.8" y="29.5" transform="rotate(270 47.8 29.5)">30.18x10KB</text><path class="cool" d="M48 60V29.82h1V60z"/><text x="48.8" y="29.5" transform="rotate(270 48.8 29.5)">30.18x10KB</text><text class="cool" x="41" y="63.75" transform="rotate(290 41 63.75)">Serialize</text><text class="cool" x="43.9" y="64.75" transform="rotate(290 43.9 64.75)">Deserialize</text><text x="46.9" y="64.5" transform="rotate(290 46.9 64.5)">Size (KB)</text><text class="case" x="43" y="67">string</text><path class="zero" d="M51 60V34.57h1V60z"/><text x="51.8" y="34.3" transform="rotate(270 51.8 34.3)">25.43x10ms</text><path class="cool" d="M52 60v-5.75h1V60z"/><text x="52.8" y="53.9" transform="rotate(270 52.8 53.9)">5.75x10ms</text><path class="zero" d="M54 60V39.92h1V60z"/><text x="54.8" y="39.6" transform="rotate(270 54.8 39.6)">20.08x10ms</text><path class="cool" d="M55 60v-2.07h1V60z"/><text x="55.8" y="57.6" transform="rotate(270 55.8 57.6)">2.07x10ms</text><path class="zero" d="M57 60v-1.18h1V60z"/><text x="57.8" y="58.52" transform="rotate(270 57.8 58.52)">1.18KB</text><path class="cool" d="M58 60v-1.18h1V60z"/><text x="58.8" y="58.52" transform="rotate(270 58.8 58.52)">1.18KB</text><text class="cool" x="51" y="63.75" transform="rotate(290 51 63.75)">Serialize</text><text class="cool" x="53.9" y="64.75" transform="rotate(290 53.9 64.75)">Deserialize</text><text x="56.9" y="64.5" transform="rotate(290 56.9 64.5)">Size (byte)</text><text class="case" x="51" y="67">Vector3[]</text><path d="M0 0v60h60V0z"/></svg>
      <p>
        As predicted, our serializer had excellent performance in the struct cases.
        <br/>
        We do lose out a few times. I'm guessing that in the case of <code class="language-csharp"><span class="csharp-blue">Person</span></code> and <code class="language-csharp"><span class="csharp-blue">Person</span>[]</code>, the UTF-8 encoding adds a lot of overhead.
      </p>
    </section>
    
    <section>
      <header>
        <h4>Experimenting with UTF-8</h4>
      </header>
      <p>
        If we avoid remove the UTF-8 code, we can use a pre-built methods for reading strings from the stream.
        Note that the memory footprint of strings essentially doubles.
      </p>
    </section>
<pre><code class="language-csharp"><span class="csharp-blue">public static string</span> <span class="csharp-gold">ReadString</span>(<span class="csharp-blue">this</span> <span class="csharp-teal">Stream</span> <span class="csharp-navy">stream</span>)
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">length</span> = <span class="csharp-navy">stream</span>.<span class="csharp-gold">Read</span>&lt;<span class="csharp-blue">int</span>&gt;();
    <span class="csharp-purple">return</span> <span class="csharp-blue">string</span>.<span class="csharp-gold">Create</span>(<span class="csharp-navy">length</span>, <span class="csharp-navy">stream</span>, (<span class="csharp-navy">chars</span>, <span class="csharp-navy">streamToUse</span>) =&gt;
    {
        <span class="csharp-blue">var</span> <span class="csharp-navy">bytes</span> = <span class="csharp-teal">MemoryMarshal</span>.<span class="csharp-gold">AsBytes</span>(<span class="csharp-navy">chars</span>);
        <span class="csharp-navy">streamToUse</span>.<span class="csharp-gold">Read</span>(<span class="csharp-navy">bytes</span>);
    });
}
</code></pre>
      <p>
        The resulting times go down by a lot!
        <br/><code class="language-csharp"><span class="csharp-blue">string</span></code> goes from 19599 ms for deserializing and 29779 ms for serializing, to 2121 ms and 7569 ms respectively.
        <br/><code class="language-csharp"><span class="csharp-teal">Person</span></code> also sees improvement. It's not as drastic but does make it faster than ZeroFormatter.
      </p>
    <section>
      <header>
        <h4>My use-case</h4>
      </header>
      <p>
        This is the data structure storing my DAWG from <a href="https://jbp.dev/blog/dawg-memory-footprint.html" title="Directed Acyclic Word Graphs - Part 3 - Reducing DAWG memory footprint">the third article</a> in that series.
        I'm going to use it to test our new method against ZeroFormatter as well as .NET's
        <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netcore-2.1" title="BinaryFormatter Class">
          BinaryFormatter</a>.
        When loaded with a typical dictionary it consumes just over 1.4MB of memory.
      </p>
      <pre><code class="language-csharp"><span class="csharp-blue">private readonly int</span> _terminalNodeIndex;
<span class="csharp-blue">private readonly int</span> _rootNodeIndex;
<span class="csharp-blue">private readonly int</span>[] _firstChildEdgeIndex; // length: 38,745
<span class="csharp-blue">private readonly int</span>[] _edgesToNodeIndex; //length: 85,600
<span class="csharp-blue">private readonly char</span>[] _edgeCharacter; //length: 85,600
<span class="csharp-blue">private readonly ushort</span>[] _reachableTerminalNodes; // length: 38,744
<span class="csharp-blue">private readonly long</span>[] _wordCount; //length: 82,765</code></pre>
      <p>
        After some initial warm up to avoid JIT issues, I loaded the object from disk 1000 times with each method and here are the results.
      </p>
      <ul>
        <li>
            Custom: 495ms
        </li>
        <li>
          BinaryFormatter: 2162ms
        </li>
        <li>
          ZeroFormatter: 923ms
        </li>
      </ul>
      <p>
        I win!
        This shouldn't come as a surprise. 
        We're using a hand-coded serializer and working with its specialty, unmanaged arrays. 
        The other methods have to rely on reflection which can be a substantial burden, but they have the advantage of requiring less work to setup.
      </p>
      <p>
        The size of the files are also slightly different.
        <ul>
          <li>
            Custom: 1,322,620 bytes
          </li>
          <li>
            BinaryFormatter: 1,322,944 bytes
          </li>
          <li>
            ZeroFormatter: 1,408,252 bytes
          </li>
        </ul>
      </p>
      <p>
        Impressively, BinaryFormatter is very close to the custom format in size.
        I'm guessing the slight difference is from storing type information.
        The larger size of the ZeroFormatter file is almost assuredly from not converting the <code class="language-csharp"><span class="csharp-blue">char</span>[]</code> to UTF-8.
        I'm surprised it doesn't, as it's output for <code class="language-csharp"><span class="csharp-blue">string</span></code> matched our size.
      </p>
    </section>
  </section>
  <section>
    <header>
    <h3>Hack for .NET Framework</h3>
    </header>
    <p>
      Without <code class="language-csharp"><span class="csharp-teal">Span</span>&lt;<span class="csharp-blue">T</span>&gt;</code>,
      this method isn't feasible and we have to make do with <code class="language-csharp"><span class="csharp-gold">Write</span>(<span class="csharp-blue">byte</span>[], <span class="csharp-blue">int</span>, <span class="csharp-blue">int</span>)</code>.
      How can we convert an arbitrary type to a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code>?
      Unions aren't quite right: if the type's size is larger than a single byte, the <code class="language-csharp">Length</code> property is much too small and the
      <code class="language-csharp"><span class="csharp-teal">Stream</span></code> methods will complain when they perform bounds checking.
      Unsafe pointers won't do either, casting to a <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code> blows up.
      Using both, we can do some bad things...
    </p>
<pre><code class="language-csharp"><span class="csharp-blue">var</span> <span class="csharp-purple">wrapper</span> = <span class="csharp-blue">new</span> <span class="csharp-teal">UnionArrayInt</span> {Typed = <span class="csharp-purple">value</span>};
<span class="csharp-gold">Write</span>(<span class="csharp-purple">wrapper</span>.Typed, <span class="csharp-purple">wrapper</span>.Bytes);

[<span class="csharp-teal">StructLayout</span>(<span class="csharp-teal">LayoutKind</span>.Explicit)]
<span class="csharp-blue">public struct</span> <span class="csharp-teal">UnionArrayInt</span>
{
    [<span class="csharp-teal">FieldOffset</span>(0)]
    <span class="csharp-blue">public readonly byte</span>[] Bytes;

    [<span class="csharp-teal">FieldOffset</span>(0)]
    <span class="csharp-blue">public int</span>[] Typed;
}

<span class="csharp-blue">public void</span> <span class="csharp-gold">Write</span>&lt;<span class="csharp-teal">T</span>&gt;(<span class="csharp-teal">T</span>[] <span class="csharp-navy">value</span>, <span class="csharp-blue">byte</span>[] <span class="csharp-navy">bytes</span>)
    <span class="csharp-blue">where</span> <span class="csharp-teal">T</span> : <span class="csharp-blue">unmanaged</span>
{
    <span class="csharp-blue">var</span> <span class="csharp-navy">oldLength</span> = <span class="csharp-navy">value</span>.Length;
    Stream.<span class="csharp-gold">WriteInt32</span>(<span class="csharp-navy">oldLength</span>);
    
    <span class="csharp-blue">unsafe</span>
    {
        <span class="csharp-blue">fixed</span> (<span class="csharp-teal">T</span>* <span class="csharp-navy">typedPointer</span> = <span class="csharp-navy">value</span>)
        {
            <span class="csharp-blue">var</span> <span class="csharp-purple">intPointer</span> = (<span class="csharp-teal">IntPtr</span>*) <span class="csharp-purple">typedPointer</span>;
            <span class="csharp-purple">try</span>
            {
                *(<span class="csharp-navy">intPointer</span> - 1) = <span class="csharp-blue">new</span> <span class="csharp-teal">IntPtr</span>(<span class="csharp-blue">sizeof</span>(<span class="csharp-teal">T</span>) * <span class="csharp-navy">oldLength</span>);
                Stream.<span class="csharp-gold">Write</span>(<span class="csharp-navy">bytes</span>, 0, <span class="csharp-navy">bytes</span>.Length);
            }
            <span class="csharp-purple">finally</span>
            {
                *(<span class="csharp-navy">intPointer</span> - 1) = new <span class="csharp-teal">IntPtr</span>(<span class="csharp-navy">oldLength</span>);
            }
        }
    }
}</code></pre>
    <p>
      Unfortunately, you'll have to write a union struct for each type you want to use this way.
      I wasn't able to create a generic container.
    </p>
    <p>
      The magic part: <code class="language-csharp">*(<span class="csharp-purple">intPointer</span> - 1)</code>
      <br/>
      By using pointers to edit the length field of the array, I can trick <code class="language-csharp">Stream</code>'s methods into accepting it as a fake <code class="language-csharp"><span class="csharp-blue">byte</span>[]</code>.
      <br/>
      It is important to note that I used IntPtr here not as an actual pointer, but as a representative of the word size of the processor. 
      Otherwise, when 32 bit you'd have to use <code class="language-csharp"><span class="csharp-blue">int</span></code>, while targeting 64 bit would require <code class="language-csharp"><span class="csharp-blue">long</span></code>.
    </p>
    <p>
      This relies on the memory layout of arrays.
      I don't know what kind of guarantee you can expect that it will always be at the same location.
      This is truly an example of: <blockquote><em>It works on my PC</em></blockquote>
      Not to mention it requires endianness to match.
    </p>
  </section>
  <section>
    <header>
      <h3>Concluding thoughts</h3>
    </header>
    <p>
      In the end it all depends on your requirements.
      Are you serializing bits and bytes? Do you have a need for speed?
      If so, this is a great way to do it.
      Otherwise, existing serialization libraries make it much easier to write maintainable code.
    </p>
    <p>If you missed the link to the code, here it is: <a href="https://github.com/jeanbern/jeanbern.github.io/blob/master/code/StreamExtensions.cs" title="StreamExtensions.cs">StreamExtensions.cs</a></p>
  </section>
</article>
</main>

<aside>
  <figure>
    <img src="https://jbp.dev/img/bird-small.jpg" alt="You caught me, I'm not a bird."/>
    <figcaption>Jean-Bernard Pellerin</figcaption>
  </figure>
  <p>
    Contact:
    I can be reached <a href="mailto:jbp@jbp.dev">by email</a>.
  </p>
</aside>

<footer>
  <p>
    <b><a href="https://jbp.dev/licenses.html">Â© 2019 Jean-Bernard Pellerin</a></b>
  </p>
</footer>  

</body>
</html>
